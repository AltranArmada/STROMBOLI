// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Cfg_Flux_IP.hxx"

// PROTOCOLType
// 

const PROTOCOLType::Type_type& PROTOCOLType::
Type () const
{
  return this->Type_.get ();
}

PROTOCOLType::Type_type& PROTOCOLType::
Type ()
{
  return this->Type_.get ();
}

void PROTOCOLType::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void PROTOCOLType::
Type (::std::unique_ptr< Type_type > x)
{
  this->Type_.set (std::move (x));
}

const PROTOCOLType::Adresse_type& PROTOCOLType::
Adresse () const
{
  return this->Adresse_.get ();
}

PROTOCOLType::Adresse_type& PROTOCOLType::
Adresse ()
{
  return this->Adresse_.get ();
}

void PROTOCOLType::
Adresse (const Adresse_type& x)
{
  this->Adresse_.set (x);
}

void PROTOCOLType::
Adresse (::std::unique_ptr< Adresse_type > x)
{
  this->Adresse_.set (std::move (x));
}


// FLUXType
// 

const FLUXType::NOM_type& FLUXType::
NOM () const
{
  return this->NOM_.get ();
}

FLUXType::NOM_type& FLUXType::
NOM ()
{
  return this->NOM_.get ();
}

void FLUXType::
NOM (const NOM_type& x)
{
  this->NOM_.set (x);
}

void FLUXType::
NOM (::std::unique_ptr< NOM_type > x)
{
  this->NOM_.set (std::move (x));
}

const FLUXType::PORT_type& FLUXType::
PORT () const
{
  return this->PORT_.get ();
}

FLUXType::PORT_type& FLUXType::
PORT ()
{
  return this->PORT_.get ();
}

void FLUXType::
PORT (const PORT_type& x)
{
  this->PORT_.set (x);
}

const FLUXType::PROTOCOL_type& FLUXType::
PROTOCOL () const
{
  return this->PROTOCOL_.get ();
}

FLUXType::PROTOCOL_type& FLUXType::
PROTOCOL ()
{
  return this->PROTOCOL_.get ();
}

void FLUXType::
PROTOCOL (const PROTOCOL_type& x)
{
  this->PROTOCOL_.set (x);
}

void FLUXType::
PROTOCOL (::std::unique_ptr< PROTOCOL_type > x)
{
  this->PROTOCOL_.set (std::move (x));
}

const FLUXType::IDENTIFIANT_optional& FLUXType::
IDENTIFIANT () const
{
  return this->IDENTIFIANT_;
}

FLUXType::IDENTIFIANT_optional& FLUXType::
IDENTIFIANT ()
{
  return this->IDENTIFIANT_;
}

void FLUXType::
IDENTIFIANT (const IDENTIFIANT_type& x)
{
  this->IDENTIFIANT_.set (x);
}

void FLUXType::
IDENTIFIANT (const IDENTIFIANT_optional& x)
{
  this->IDENTIFIANT_ = x;
}

void FLUXType::
IDENTIFIANT (::std::unique_ptr< IDENTIFIANT_type > x)
{
  this->IDENTIFIANT_.set (std::move (x));
}

const FLUXType::IP_Emetteur_optional& FLUXType::
IP_Emetteur () const
{
  return this->IP_Emetteur_;
}

FLUXType::IP_Emetteur_optional& FLUXType::
IP_Emetteur ()
{
  return this->IP_Emetteur_;
}

void FLUXType::
IP_Emetteur (const IP_Emetteur_type& x)
{
  this->IP_Emetteur_.set (x);
}

void FLUXType::
IP_Emetteur (const IP_Emetteur_optional& x)
{
  this->IP_Emetteur_ = x;
}

void FLUXType::
IP_Emetteur (::std::unique_ptr< IP_Emetteur_type > x)
{
  this->IP_Emetteur_.set (std::move (x));
}

const FLUXType::IP_Dest_optional& FLUXType::
IP_Dest () const
{
  return this->IP_Dest_;
}

FLUXType::IP_Dest_optional& FLUXType::
IP_Dest ()
{
  return this->IP_Dest_;
}

void FLUXType::
IP_Dest (const IP_Dest_type& x)
{
  this->IP_Dest_.set (x);
}

void FLUXType::
IP_Dest (const IP_Dest_optional& x)
{
  this->IP_Dest_ = x;
}

void FLUXType::
IP_Dest (::std::unique_ptr< IP_Dest_type > x)
{
  this->IP_Dest_.set (std::move (x));
}

const FLUXType::DATA_FORMAT_optional& FLUXType::
DATA_FORMAT () const
{
  return this->DATA_FORMAT_;
}

FLUXType::DATA_FORMAT_optional& FLUXType::
DATA_FORMAT ()
{
  return this->DATA_FORMAT_;
}

void FLUXType::
DATA_FORMAT (const DATA_FORMAT_type& x)
{
  this->DATA_FORMAT_.set (x);
}

void FLUXType::
DATA_FORMAT (const DATA_FORMAT_optional& x)
{
  this->DATA_FORMAT_ = x;
}

void FLUXType::
DATA_FORMAT (::std::unique_ptr< DATA_FORMAT_type > x)
{
  this->DATA_FORMAT_.set (std::move (x));
}


// BDD_Cfg_FluxIPType
// 

const BDD_Cfg_FluxIPType::FLUX_type& BDD_Cfg_FluxIPType::
FLUX () const
{
  return this->FLUX_.get ();
}

BDD_Cfg_FluxIPType::FLUX_type& BDD_Cfg_FluxIPType::
FLUX ()
{
  return this->FLUX_.get ();
}

void BDD_Cfg_FluxIPType::
FLUX (const FLUX_type& x)
{
  this->FLUX_.set (x);
}

void BDD_Cfg_FluxIPType::
FLUX (::std::unique_ptr< FLUX_type > x)
{
  this->FLUX_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// PROTOCOLType
//

PROTOCOLType::
PROTOCOLType (const Type_type& Type,
              const Adresse_type& Adresse)
: ::xml_schema::type (),
  Type_ (Type, this),
  Adresse_ (Adresse, this)
{
}

PROTOCOLType::
PROTOCOLType (const PROTOCOLType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Type_ (x.Type_, f, this),
  Adresse_ (x.Adresse_, f, this)
{
}

PROTOCOLType::
PROTOCOLType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Type_ (this),
  Adresse_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PROTOCOLType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Type
    //
    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Type_type > r (
        Type_traits::create (i, f, this));

      if (!Type_.present ())
      {
        this->Type_.set (::std::move (r));
        continue;
      }
    }

    // Adresse
    //
    if (n.name () == "Adresse" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Adresse_type > r (
        Adresse_traits::create (i, f, this));

      if (!Adresse_.present ())
      {
        this->Adresse_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Type",
      "");
  }

  if (!Adresse_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Adresse",
      "");
  }
}

PROTOCOLType* PROTOCOLType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PROTOCOLType (*this, f, c);
}

PROTOCOLType& PROTOCOLType::
operator= (const PROTOCOLType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Type_ = x.Type_;
    this->Adresse_ = x.Adresse_;
  }

  return *this;
}

PROTOCOLType::
~PROTOCOLType ()
{
}

// FLUXType
//

FLUXType::
FLUXType (const NOM_type& NOM,
          const PORT_type& PORT,
          const PROTOCOL_type& PROTOCOL)
: ::xml_schema::type (),
  NOM_ (NOM, this),
  PORT_ (PORT, this),
  PROTOCOL_ (PROTOCOL, this),
  IDENTIFIANT_ (this),
  IP_Emetteur_ (this),
  IP_Dest_ (this),
  DATA_FORMAT_ (this)
{
}

FLUXType::
FLUXType (const NOM_type& NOM,
          const PORT_type& PORT,
          ::std::unique_ptr< PROTOCOL_type > PROTOCOL)
: ::xml_schema::type (),
  NOM_ (NOM, this),
  PORT_ (PORT, this),
  PROTOCOL_ (std::move (PROTOCOL), this),
  IDENTIFIANT_ (this),
  IP_Emetteur_ (this),
  IP_Dest_ (this),
  DATA_FORMAT_ (this)
{
}

FLUXType::
FLUXType (const FLUXType& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NOM_ (x.NOM_, f, this),
  PORT_ (x.PORT_, f, this),
  PROTOCOL_ (x.PROTOCOL_, f, this),
  IDENTIFIANT_ (x.IDENTIFIANT_, f, this),
  IP_Emetteur_ (x.IP_Emetteur_, f, this),
  IP_Dest_ (x.IP_Dest_, f, this),
  DATA_FORMAT_ (x.DATA_FORMAT_, f, this)
{
}

FLUXType::
FLUXType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NOM_ (this),
  PORT_ (this),
  PROTOCOL_ (this),
  IDENTIFIANT_ (this),
  IP_Emetteur_ (this),
  IP_Dest_ (this),
  DATA_FORMAT_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void FLUXType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NOM
    //
    if (n.name () == "NOM" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< NOM_type > r (
        NOM_traits::create (i, f, this));

      if (!NOM_.present ())
      {
        this->NOM_.set (::std::move (r));
        continue;
      }
    }

    // PORT
    //
    if (n.name () == "PORT" && n.namespace_ ().empty ())
    {
      if (!PORT_.present ())
      {
        this->PORT_.set (PORT_traits::create (i, f, this));
        continue;
      }
    }

    // PROTOCOL
    //
    if (n.name () == "PROTOCOL" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< PROTOCOL_type > r (
        PROTOCOL_traits::create (i, f, this));

      if (!PROTOCOL_.present ())
      {
        this->PROTOCOL_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!NOM_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "NOM",
      "");
  }

  if (!PORT_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PORT",
      "");
  }

  if (!PROTOCOL_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "PROTOCOL",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "IDENTIFIANT" && n.namespace_ ().empty ())
    {
      this->IDENTIFIANT_.set (IDENTIFIANT_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IP_Emetteur" && n.namespace_ ().empty ())
    {
      this->IP_Emetteur_.set (IP_Emetteur_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IP_Dest" && n.namespace_ ().empty ())
    {
      this->IP_Dest_.set (IP_Dest_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "DATA_FORMAT" && n.namespace_ ().empty ())
    {
      this->DATA_FORMAT_.set (DATA_FORMAT_traits::create (i, f, this));
      continue;
    }
  }
}

FLUXType* FLUXType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FLUXType (*this, f, c);
}

FLUXType& FLUXType::
operator= (const FLUXType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NOM_ = x.NOM_;
    this->PORT_ = x.PORT_;
    this->PROTOCOL_ = x.PROTOCOL_;
    this->IDENTIFIANT_ = x.IDENTIFIANT_;
    this->IP_Emetteur_ = x.IP_Emetteur_;
    this->IP_Dest_ = x.IP_Dest_;
    this->DATA_FORMAT_ = x.DATA_FORMAT_;
  }

  return *this;
}

FLUXType::
~FLUXType ()
{
}

// BDD_Cfg_FluxIPType
//

BDD_Cfg_FluxIPType::
BDD_Cfg_FluxIPType (const FLUX_type& FLUX)
: ::xml_schema::type (),
  FLUX_ (FLUX, this)
{
}

BDD_Cfg_FluxIPType::
BDD_Cfg_FluxIPType (::std::unique_ptr< FLUX_type > FLUX)
: ::xml_schema::type (),
  FLUX_ (std::move (FLUX), this)
{
}

BDD_Cfg_FluxIPType::
BDD_Cfg_FluxIPType (const BDD_Cfg_FluxIPType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  FLUX_ (x.FLUX_, f, this)
{
}

BDD_Cfg_FluxIPType::
BDD_Cfg_FluxIPType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  FLUX_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void BDD_Cfg_FluxIPType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // FLUX
    //
    if (n.name () == "FLUX" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FLUX_type > r (
        FLUX_traits::create (i, f, this));

      if (!FLUX_.present ())
      {
        this->FLUX_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!FLUX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "FLUX",
      "");
  }
}

BDD_Cfg_FluxIPType* BDD_Cfg_FluxIPType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BDD_Cfg_FluxIPType (*this, f, c);
}

BDD_Cfg_FluxIPType& BDD_Cfg_FluxIPType::
operator= (const BDD_Cfg_FluxIPType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->FLUX_ = x.FLUX_;
  }

  return *this;
}

BDD_Cfg_FluxIPType::
~BDD_Cfg_FluxIPType ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::BDD_Cfg_FluxIPType >
BDD_Cfg_FluxIP (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::BDD_Cfg_FluxIPType > (
    ::BDD_Cfg_FluxIP (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::BDD_Cfg_FluxIPType >
BDD_Cfg_FluxIP (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::BDD_Cfg_FluxIPType > (
    ::BDD_Cfg_FluxIP (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::BDD_Cfg_FluxIPType >
BDD_Cfg_FluxIP (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::BDD_Cfg_FluxIPType > (
    ::BDD_Cfg_FluxIP (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::BDD_Cfg_FluxIPType >
BDD_Cfg_FluxIP (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::BDD_Cfg_FluxIP (isrc, f, p);
}

::std::unique_ptr< ::BDD_Cfg_FluxIPType >
BDD_Cfg_FluxIP (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::BDD_Cfg_FluxIP (isrc, h, f, p);
}

::std::unique_ptr< ::BDD_Cfg_FluxIPType >
BDD_Cfg_FluxIP (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::BDD_Cfg_FluxIP (isrc, h, f, p);
}

::std::unique_ptr< ::BDD_Cfg_FluxIPType >
BDD_Cfg_FluxIP (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::BDD_Cfg_FluxIP (isrc, f, p);
}

::std::unique_ptr< ::BDD_Cfg_FluxIPType >
BDD_Cfg_FluxIP (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::BDD_Cfg_FluxIP (isrc, h, f, p);
}

::std::unique_ptr< ::BDD_Cfg_FluxIPType >
BDD_Cfg_FluxIP (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::BDD_Cfg_FluxIP (isrc, h, f, p);
}

::std::unique_ptr< ::BDD_Cfg_FluxIPType >
BDD_Cfg_FluxIP (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::BDD_Cfg_FluxIPType > (
    ::BDD_Cfg_FluxIP (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::BDD_Cfg_FluxIPType >
BDD_Cfg_FluxIP (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::BDD_Cfg_FluxIPType > (
    ::BDD_Cfg_FluxIP (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::BDD_Cfg_FluxIPType >
BDD_Cfg_FluxIP (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::BDD_Cfg_FluxIPType > (
    ::BDD_Cfg_FluxIP (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::BDD_Cfg_FluxIPType >
BDD_Cfg_FluxIP (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::BDD_Cfg_FluxIPType > (
      ::BDD_Cfg_FluxIP (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "BDD_Cfg_FluxIP" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::BDD_Cfg_FluxIPType > r (
      ::xsd::cxx::tree::traits< ::BDD_Cfg_FluxIPType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "BDD_Cfg_FluxIP",
    "");
}

::std::unique_ptr< ::BDD_Cfg_FluxIPType >
BDD_Cfg_FluxIP (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "BDD_Cfg_FluxIP" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::BDD_Cfg_FluxIPType > r (
      ::xsd::cxx::tree::traits< ::BDD_Cfg_FluxIPType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "BDD_Cfg_FluxIP",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

