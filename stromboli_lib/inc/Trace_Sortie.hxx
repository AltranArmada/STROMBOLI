// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef C__D_SAFRAN_STROMBOLI_SVN_STROMBOLI_XSD_TRACE_SORTIE_HXX
#define C__D_SAFRAN_STROMBOLI_SVN_STROMBOLI_XSD_TRACE_SORTIE_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class EXIGENCESType;
class LOGICIELType;
class MATERIELType;
class CONFIGURATIONType;
class TEST_REFType;
class FILESType;
class TOOL_CFGType;
class IP_PROTOCOLType;
class TRANSMISSION_PROTOCOLType;
class DATAType;
class DATA_SETType;
class FRAMEType;
class OUTPUTType;
class BDD_OUTPUT_DATAType;
class DATATypeTYPE;
class FRAMETypeIDENTIFIANT;
class FRAMETypeNOM;
class FRAMETypeSOURCE;
class FRAMETypeDESTINATION;
class FRAMETypeTYPE;
class FRAMETypeFRAME_NUMBER;

#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class EXIGENCESType: public ::xml_schema::type
{
  public:
  // ID_EXI
  //
  typedef ::xml_schema::string ID_EXI_type;
  typedef ::xsd::cxx::tree::sequence< ID_EXI_type > ID_EXI_sequence;
  typedef ID_EXI_sequence::iterator ID_EXI_iterator;
  typedef ID_EXI_sequence::const_iterator ID_EXI_const_iterator;
  typedef ::xsd::cxx::tree::traits< ID_EXI_type, char > ID_EXI_traits;

  const ID_EXI_sequence&
  ID_EXI () const;

  ID_EXI_sequence&
  ID_EXI ();

  void
  ID_EXI (const ID_EXI_sequence& s);

  // Constructors.
  //
  EXIGENCESType ();

  EXIGENCESType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  EXIGENCESType (const EXIGENCESType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual EXIGENCESType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  EXIGENCESType&
  operator= (const EXIGENCESType& x);

  virtual 
  ~EXIGENCESType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ID_EXI_sequence ID_EXI_;
};

class LOGICIELType: public ::xml_schema::type
{
  public:
  // SSG
  //
  typedef ::xml_schema::string SSG_type;
  typedef ::xsd::cxx::tree::traits< SSG_type, char > SSG_traits;

  const SSG_type&
  SSG () const;

  SSG_type&
  SSG ();

  void
  SSG (const SSG_type& x);

  void
  SSG (::std::auto_ptr< SSG_type > p);

  // SST
  //
  typedef ::xml_schema::string SST_type;
  typedef ::xsd::cxx::tree::traits< SST_type, char > SST_traits;

  const SST_type&
  SST () const;

  SST_type&
  SST ();

  void
  SST (const SST_type& x);

  void
  SST (::std::auto_ptr< SST_type > p);

  // Constructors.
  //
  LOGICIELType (const SSG_type&,
                const SST_type&);

  LOGICIELType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  LOGICIELType (const LOGICIELType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual LOGICIELType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  LOGICIELType&
  operator= (const LOGICIELType& x);

  virtual 
  ~LOGICIELType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< SSG_type > SSG_;
  ::xsd::cxx::tree::one< SST_type > SST_;
};

class MATERIELType: public ::xml_schema::type
{
  public:
  // SSG
  //
  typedef ::xml_schema::string SSG_type;
  typedef ::xsd::cxx::tree::traits< SSG_type, char > SSG_traits;

  const SSG_type&
  SSG () const;

  SSG_type&
  SSG ();

  void
  SSG (const SSG_type& x);

  void
  SSG (::std::auto_ptr< SSG_type > p);

  // SST
  //
  typedef ::xml_schema::string SST_type;
  typedef ::xsd::cxx::tree::traits< SST_type, char > SST_traits;

  const SST_type&
  SST () const;

  SST_type&
  SST ();

  void
  SST (const SST_type& x);

  void
  SST (::std::auto_ptr< SST_type > p);

  // Constructors.
  //
  MATERIELType (const SSG_type&,
                const SST_type&);

  MATERIELType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  MATERIELType (const MATERIELType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual MATERIELType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  MATERIELType&
  operator= (const MATERIELType& x);

  virtual 
  ~MATERIELType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< SSG_type > SSG_;
  ::xsd::cxx::tree::one< SST_type > SST_;
};

class CONFIGURATIONType: public ::xml_schema::type
{
  public:
  // LOGICIEL
  //
  typedef ::LOGICIELType LOGICIEL_type;
  typedef ::xsd::cxx::tree::traits< LOGICIEL_type, char > LOGICIEL_traits;

  const LOGICIEL_type&
  LOGICIEL () const;

  LOGICIEL_type&
  LOGICIEL ();

  void
  LOGICIEL (const LOGICIEL_type& x);

  void
  LOGICIEL (::std::auto_ptr< LOGICIEL_type > p);

  // MATERIEL
  //
  typedef ::MATERIELType MATERIEL_type;
  typedef ::xsd::cxx::tree::traits< MATERIEL_type, char > MATERIEL_traits;

  const MATERIEL_type&
  MATERIEL () const;

  MATERIEL_type&
  MATERIEL ();

  void
  MATERIEL (const MATERIEL_type& x);

  void
  MATERIEL (::std::auto_ptr< MATERIEL_type > p);

  // Constructors.
  //
  CONFIGURATIONType (const LOGICIEL_type&,
                     const MATERIEL_type&);

  CONFIGURATIONType (::std::auto_ptr< LOGICIEL_type >,
                     ::std::auto_ptr< MATERIEL_type >);

  CONFIGURATIONType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  CONFIGURATIONType (const CONFIGURATIONType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual CONFIGURATIONType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CONFIGURATIONType&
  operator= (const CONFIGURATIONType& x);

  virtual 
  ~CONFIGURATIONType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< LOGICIEL_type > LOGICIEL_;
  ::xsd::cxx::tree::one< MATERIEL_type > MATERIEL_;
};

class TEST_REFType: public ::xml_schema::type
{
  public:
  // TEST_ID
  //
  typedef ::xml_schema::string TEST_ID_type;
  typedef ::xsd::cxx::tree::traits< TEST_ID_type, char > TEST_ID_traits;

  const TEST_ID_type&
  TEST_ID () const;

  TEST_ID_type&
  TEST_ID ();

  void
  TEST_ID (const TEST_ID_type& x);

  void
  TEST_ID (::std::auto_ptr< TEST_ID_type > p);

  // ORIGINE
  //
  typedef ::xml_schema::string ORIGINE_type;
  typedef ::xsd::cxx::tree::traits< ORIGINE_type, char > ORIGINE_traits;

  const ORIGINE_type&
  ORIGINE () const;

  ORIGINE_type&
  ORIGINE ();

  void
  ORIGINE (const ORIGINE_type& x);

  void
  ORIGINE (::std::auto_ptr< ORIGINE_type > p);

  // TITRE
  //
  typedef ::xml_schema::string TITRE_type;
  typedef ::xsd::cxx::tree::traits< TITRE_type, char > TITRE_traits;

  const TITRE_type&
  TITRE () const;

  TITRE_type&
  TITRE ();

  void
  TITRE (const TITRE_type& x);

  void
  TITRE (::std::auto_ptr< TITRE_type > p);

  // REFERENCE_PROCEDURE
  //
  typedef ::xml_schema::string REFERENCE_PROCEDURE_type;
  typedef ::xsd::cxx::tree::traits< REFERENCE_PROCEDURE_type, char > REFERENCE_PROCEDURE_traits;

  const REFERENCE_PROCEDURE_type&
  REFERENCE_PROCEDURE () const;

  REFERENCE_PROCEDURE_type&
  REFERENCE_PROCEDURE ();

  void
  REFERENCE_PROCEDURE (const REFERENCE_PROCEDURE_type& x);

  void
  REFERENCE_PROCEDURE (::std::auto_ptr< REFERENCE_PROCEDURE_type > p);

  // VERSION_PROCEDURE
  //
  typedef ::xml_schema::string VERSION_PROCEDURE_type;
  typedef ::xsd::cxx::tree::traits< VERSION_PROCEDURE_type, char > VERSION_PROCEDURE_traits;

  const VERSION_PROCEDURE_type&
  VERSION_PROCEDURE () const;

  VERSION_PROCEDURE_type&
  VERSION_PROCEDURE ();

  void
  VERSION_PROCEDURE (const VERSION_PROCEDURE_type& x);

  void
  VERSION_PROCEDURE (::std::auto_ptr< VERSION_PROCEDURE_type > p);

  // SECTION_PROCEDURE
  //
  typedef ::xml_schema::string SECTION_PROCEDURE_type;
  typedef ::xsd::cxx::tree::traits< SECTION_PROCEDURE_type, char > SECTION_PROCEDURE_traits;

  const SECTION_PROCEDURE_type&
  SECTION_PROCEDURE () const;

  SECTION_PROCEDURE_type&
  SECTION_PROCEDURE ();

  void
  SECTION_PROCEDURE (const SECTION_PROCEDURE_type& x);

  void
  SECTION_PROCEDURE (::std::auto_ptr< SECTION_PROCEDURE_type > p);

  // EXIGENCES
  //
  typedef ::EXIGENCESType EXIGENCES_type;
  typedef ::xsd::cxx::tree::traits< EXIGENCES_type, char > EXIGENCES_traits;

  const EXIGENCES_type&
  EXIGENCES () const;

  EXIGENCES_type&
  EXIGENCES ();

  void
  EXIGENCES (const EXIGENCES_type& x);

  void
  EXIGENCES (::std::auto_ptr< EXIGENCES_type > p);

  // CONFIGURATION
  //
  typedef ::CONFIGURATIONType CONFIGURATION_type;
  typedef ::xsd::cxx::tree::traits< CONFIGURATION_type, char > CONFIGURATION_traits;

  const CONFIGURATION_type&
  CONFIGURATION () const;

  CONFIGURATION_type&
  CONFIGURATION ();

  void
  CONFIGURATION (const CONFIGURATION_type& x);

  void
  CONFIGURATION (::std::auto_ptr< CONFIGURATION_type > p);

  // DATE
  //
  typedef ::xml_schema::date DATE_type;
  typedef ::xsd::cxx::tree::traits< DATE_type, char > DATE_traits;

  const DATE_type&
  DATE () const;

  DATE_type&
  DATE ();

  void
  DATE (const DATE_type& x);

  void
  DATE (::std::auto_ptr< DATE_type > p);

  // HEURE
  //
  typedef ::xml_schema::time HEURE_type;
  typedef ::xsd::cxx::tree::traits< HEURE_type, char > HEURE_traits;

  const HEURE_type&
  HEURE () const;

  HEURE_type&
  HEURE ();

  void
  HEURE (const HEURE_type& x);

  void
  HEURE (::std::auto_ptr< HEURE_type > p);

  // LIEU
  //
  typedef ::xml_schema::string LIEU_type;
  typedef ::xsd::cxx::tree::traits< LIEU_type, char > LIEU_traits;

  const LIEU_type&
  LIEU () const;

  LIEU_type&
  LIEU ();

  void
  LIEU (const LIEU_type& x);

  void
  LIEU (::std::auto_ptr< LIEU_type > p);

  // OPERATEUR
  //
  typedef ::xml_schema::string OPERATEUR_type;
  typedef ::xsd::cxx::tree::traits< OPERATEUR_type, char > OPERATEUR_traits;

  const OPERATEUR_type&
  OPERATEUR () const;

  OPERATEUR_type&
  OPERATEUR ();

  void
  OPERATEUR (const OPERATEUR_type& x);

  void
  OPERATEUR (::std::auto_ptr< OPERATEUR_type > p);

  // COMMENT
  //
  typedef ::xml_schema::string COMMENT_type;
  typedef ::xsd::cxx::tree::traits< COMMENT_type, char > COMMENT_traits;

  const COMMENT_type&
  COMMENT () const;

  COMMENT_type&
  COMMENT ();

  void
  COMMENT (const COMMENT_type& x);

  void
  COMMENT (::std::auto_ptr< COMMENT_type > p);

  // VALIDITE
  //
  typedef ::xml_schema::string VALIDITE_type;
  typedef ::xsd::cxx::tree::traits< VALIDITE_type, char > VALIDITE_traits;

  const VALIDITE_type&
  VALIDITE () const;

  VALIDITE_type&
  VALIDITE ();

  void
  VALIDITE (const VALIDITE_type& x);

  void
  VALIDITE (::std::auto_ptr< VALIDITE_type > p);

  // SAUVEGARDE
  //
  typedef ::xml_schema::string SAUVEGARDE_type;
  typedef ::xsd::cxx::tree::traits< SAUVEGARDE_type, char > SAUVEGARDE_traits;

  const SAUVEGARDE_type&
  SAUVEGARDE () const;

  SAUVEGARDE_type&
  SAUVEGARDE ();

  void
  SAUVEGARDE (const SAUVEGARDE_type& x);

  void
  SAUVEGARDE (::std::auto_ptr< SAUVEGARDE_type > p);

  // Constructors.
  //
  TEST_REFType (const TEST_ID_type&,
                const ORIGINE_type&,
                const TITRE_type&,
                const REFERENCE_PROCEDURE_type&,
                const VERSION_PROCEDURE_type&,
                const SECTION_PROCEDURE_type&,
                const EXIGENCES_type&,
                const CONFIGURATION_type&,
                const DATE_type&,
                const HEURE_type&,
                const LIEU_type&,
                const OPERATEUR_type&,
                const COMMENT_type&,
                const VALIDITE_type&,
                const SAUVEGARDE_type&);

  TEST_REFType (const TEST_ID_type&,
                const ORIGINE_type&,
                const TITRE_type&,
                const REFERENCE_PROCEDURE_type&,
                const VERSION_PROCEDURE_type&,
                const SECTION_PROCEDURE_type&,
                ::std::auto_ptr< EXIGENCES_type >,
                ::std::auto_ptr< CONFIGURATION_type >,
                const DATE_type&,
                const HEURE_type&,
                const LIEU_type&,
                const OPERATEUR_type&,
                const COMMENT_type&,
                const VALIDITE_type&,
                const SAUVEGARDE_type&);

  TEST_REFType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  TEST_REFType (const TEST_REFType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual TEST_REFType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  TEST_REFType&
  operator= (const TEST_REFType& x);

  virtual 
  ~TEST_REFType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< TEST_ID_type > TEST_ID_;
  ::xsd::cxx::tree::one< ORIGINE_type > ORIGINE_;
  ::xsd::cxx::tree::one< TITRE_type > TITRE_;
  ::xsd::cxx::tree::one< REFERENCE_PROCEDURE_type > REFERENCE_PROCEDURE_;
  ::xsd::cxx::tree::one< VERSION_PROCEDURE_type > VERSION_PROCEDURE_;
  ::xsd::cxx::tree::one< SECTION_PROCEDURE_type > SECTION_PROCEDURE_;
  ::xsd::cxx::tree::one< EXIGENCES_type > EXIGENCES_;
  ::xsd::cxx::tree::one< CONFIGURATION_type > CONFIGURATION_;
  ::xsd::cxx::tree::one< DATE_type > DATE_;
  ::xsd::cxx::tree::one< HEURE_type > HEURE_;
  ::xsd::cxx::tree::one< LIEU_type > LIEU_;
  ::xsd::cxx::tree::one< OPERATEUR_type > OPERATEUR_;
  ::xsd::cxx::tree::one< COMMENT_type > COMMENT_;
  ::xsd::cxx::tree::one< VALIDITE_type > VALIDITE_;
  ::xsd::cxx::tree::one< SAUVEGARDE_type > SAUVEGARDE_;
};

class FILESType: public ::xml_schema::type
{
  public:
  // CFG_IP
  //
  typedef ::xml_schema::string CFG_IP_type;
  typedef ::xsd::cxx::tree::traits< CFG_IP_type, char > CFG_IP_traits;

  const CFG_IP_type&
  CFG_IP () const;

  CFG_IP_type&
  CFG_IP ();

  void
  CFG_IP (const CFG_IP_type& x);

  void
  CFG_IP (::std::auto_ptr< CFG_IP_type > p);

  // CFG_FLUX
  //
  typedef ::xml_schema::string CFG_FLUX_type;
  typedef ::xsd::cxx::tree::traits< CFG_FLUX_type, char > CFG_FLUX_traits;

  const CFG_FLUX_type&
  CFG_FLUX () const;

  CFG_FLUX_type&
  CFG_FLUX ();

  void
  CFG_FLUX (const CFG_FLUX_type& x);

  void
  CFG_FLUX (::std::auto_ptr< CFG_FLUX_type > p);

  // CFG_DATA
  //
  typedef ::xml_schema::string CFG_DATA_type;
  typedef ::xsd::cxx::tree::traits< CFG_DATA_type, char > CFG_DATA_traits;

  const CFG_DATA_type&
  CFG_DATA () const;

  CFG_DATA_type&
  CFG_DATA ();

  void
  CFG_DATA (const CFG_DATA_type& x);

  void
  CFG_DATA (::std::auto_ptr< CFG_DATA_type > p);

  // CFG_DATA_VAL
  //
  typedef ::xml_schema::string CFG_DATA_VAL_type;
  typedef ::xsd::cxx::tree::traits< CFG_DATA_VAL_type, char > CFG_DATA_VAL_traits;

  const CFG_DATA_VAL_type&
  CFG_DATA_VAL () const;

  CFG_DATA_VAL_type&
  CFG_DATA_VAL ();

  void
  CFG_DATA_VAL (const CFG_DATA_VAL_type& x);

  void
  CFG_DATA_VAL (::std::auto_ptr< CFG_DATA_VAL_type > p);

  // CFG_TEST
  //
  typedef ::xml_schema::string CFG_TEST_type;
  typedef ::xsd::cxx::tree::traits< CFG_TEST_type, char > CFG_TEST_traits;

  const CFG_TEST_type&
  CFG_TEST () const;

  CFG_TEST_type&
  CFG_TEST ();

  void
  CFG_TEST (const CFG_TEST_type& x);

  void
  CFG_TEST (::std::auto_ptr< CFG_TEST_type > p);

  // Constructors.
  //
  FILESType (const CFG_IP_type&,
             const CFG_FLUX_type&,
             const CFG_DATA_type&,
             const CFG_DATA_VAL_type&,
             const CFG_TEST_type&);

  FILESType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  FILESType (const FILESType& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual FILESType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  FILESType&
  operator= (const FILESType& x);

  virtual 
  ~FILESType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< CFG_IP_type > CFG_IP_;
  ::xsd::cxx::tree::one< CFG_FLUX_type > CFG_FLUX_;
  ::xsd::cxx::tree::one< CFG_DATA_type > CFG_DATA_;
  ::xsd::cxx::tree::one< CFG_DATA_VAL_type > CFG_DATA_VAL_;
  ::xsd::cxx::tree::one< CFG_TEST_type > CFG_TEST_;
};

class TOOL_CFGType: public ::xml_schema::type
{
  public:
  // IDENT
  //
  typedef ::xml_schema::string IDENT_type;
  typedef ::xsd::cxx::tree::traits< IDENT_type, char > IDENT_traits;

  const IDENT_type&
  IDENT () const;

  IDENT_type&
  IDENT ();

  void
  IDENT (const IDENT_type& x);

  void
  IDENT (::std::auto_ptr< IDENT_type > p);

  // VERSION
  //
  typedef ::xml_schema::string VERSION_type;
  typedef ::xsd::cxx::tree::traits< VERSION_type, char > VERSION_traits;

  const VERSION_type&
  VERSION () const;

  VERSION_type&
  VERSION ();

  void
  VERSION (const VERSION_type& x);

  void
  VERSION (::std::auto_ptr< VERSION_type > p);

  // FILES
  //
  typedef ::FILESType FILES_type;
  typedef ::xsd::cxx::tree::traits< FILES_type, char > FILES_traits;

  const FILES_type&
  FILES () const;

  FILES_type&
  FILES ();

  void
  FILES (const FILES_type& x);

  void
  FILES (::std::auto_ptr< FILES_type > p);

  // DATE
  //
  typedef ::xml_schema::date DATE_type;
  typedef ::xsd::cxx::tree::traits< DATE_type, char > DATE_traits;

  const DATE_type&
  DATE () const;

  DATE_type&
  DATE ();

  void
  DATE (const DATE_type& x);

  void
  DATE (::std::auto_ptr< DATE_type > p);

  // HEURE
  //
  typedef ::xml_schema::time HEURE_type;
  typedef ::xsd::cxx::tree::traits< HEURE_type, char > HEURE_traits;

  const HEURE_type&
  HEURE () const;

  HEURE_type&
  HEURE ();

  void
  HEURE (const HEURE_type& x);

  void
  HEURE (::std::auto_ptr< HEURE_type > p);

  // Constructors.
  //
  TOOL_CFGType (const IDENT_type&,
                const VERSION_type&,
                const FILES_type&,
                const DATE_type&,
                const HEURE_type&);

  TOOL_CFGType (const IDENT_type&,
                const VERSION_type&,
                ::std::auto_ptr< FILES_type >,
                const DATE_type&,
                const HEURE_type&);

  TOOL_CFGType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  TOOL_CFGType (const TOOL_CFGType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual TOOL_CFGType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  TOOL_CFGType&
  operator= (const TOOL_CFGType& x);

  virtual 
  ~TOOL_CFGType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< IDENT_type > IDENT_;
  ::xsd::cxx::tree::one< VERSION_type > VERSION_;
  ::xsd::cxx::tree::one< FILES_type > FILES_;
  ::xsd::cxx::tree::one< DATE_type > DATE_;
  ::xsd::cxx::tree::one< HEURE_type > HEURE_;
};

class IP_PROTOCOLType: public ::xml_schema::type
{
  public:
  // FLAGS
  //
  typedef ::xml_schema::string FLAGS_type;
  typedef ::xsd::cxx::tree::traits< FLAGS_type, char > FLAGS_traits;

  const FLAGS_type&
  FLAGS () const;

  FLAGS_type&
  FLAGS ();

  void
  FLAGS (const FLAGS_type& x);

  void
  FLAGS (::std::auto_ptr< FLAGS_type > p);

  // Header_CHECKSUM
  //
  typedef ::xml_schema::string Header_CHECKSUM_type;
  typedef ::xsd::cxx::tree::traits< Header_CHECKSUM_type, char > Header_CHECKSUM_traits;

  const Header_CHECKSUM_type&
  Header_CHECKSUM () const;

  Header_CHECKSUM_type&
  Header_CHECKSUM ();

  void
  Header_CHECKSUM (const Header_CHECKSUM_type& x);

  void
  Header_CHECKSUM (::std::auto_ptr< Header_CHECKSUM_type > p);

  // Constructors.
  //
  IP_PROTOCOLType (const FLAGS_type&,
                   const Header_CHECKSUM_type&);

  IP_PROTOCOLType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  IP_PROTOCOLType (const IP_PROTOCOLType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual IP_PROTOCOLType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  IP_PROTOCOLType&
  operator= (const IP_PROTOCOLType& x);

  virtual 
  ~IP_PROTOCOLType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< FLAGS_type > FLAGS_;
  ::xsd::cxx::tree::one< Header_CHECKSUM_type > Header_CHECKSUM_;
};

class TRANSMISSION_PROTOCOLType: public ::xml_schema::type
{
  public:
  // SEQ_NUMBER
  //
  typedef ::xml_schema::unsigned_long SEQ_NUMBER_type;
  typedef ::xsd::cxx::tree::traits< SEQ_NUMBER_type, char > SEQ_NUMBER_traits;

  const SEQ_NUMBER_type&
  SEQ_NUMBER () const;

  SEQ_NUMBER_type&
  SEQ_NUMBER ();

  void
  SEQ_NUMBER (const SEQ_NUMBER_type& x);

  // ACK_RTT
  //
  typedef ::xml_schema::string ACK_RTT_type;
  typedef ::xsd::cxx::tree::traits< ACK_RTT_type, char > ACK_RTT_traits;

  const ACK_RTT_type&
  ACK_RTT () const;

  ACK_RTT_type&
  ACK_RTT ();

  void
  ACK_RTT (const ACK_RTT_type& x);

  void
  ACK_RTT (::std::auto_ptr< ACK_RTT_type > p);

  // FLAGS
  //
  typedef ::xml_schema::string FLAGS_type;
  typedef ::xsd::cxx::tree::traits< FLAGS_type, char > FLAGS_traits;

  const FLAGS_type&
  FLAGS () const;

  FLAGS_type&
  FLAGS ();

  void
  FLAGS (const FLAGS_type& x);

  void
  FLAGS (::std::auto_ptr< FLAGS_type > p);

  // Constructors.
  //
  TRANSMISSION_PROTOCOLType (const SEQ_NUMBER_type&,
                             const ACK_RTT_type&,
                             const FLAGS_type&);

  TRANSMISSION_PROTOCOLType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  TRANSMISSION_PROTOCOLType (const TRANSMISSION_PROTOCOLType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  virtual TRANSMISSION_PROTOCOLType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  TRANSMISSION_PROTOCOLType&
  operator= (const TRANSMISSION_PROTOCOLType& x);

  virtual 
  ~TRANSMISSION_PROTOCOLType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< SEQ_NUMBER_type > SEQ_NUMBER_;
  ::xsd::cxx::tree::one< ACK_RTT_type > ACK_RTT_;
  ::xsd::cxx::tree::one< FLAGS_type > FLAGS_;
};

class DATAType: public ::xml_schema::type
{
  public:
  // DATA_ID
  //
  typedef ::xml_schema::string DATA_ID_type;
  typedef ::xsd::cxx::tree::sequence< DATA_ID_type > DATA_ID_sequence;
  typedef DATA_ID_sequence::iterator DATA_ID_iterator;
  typedef DATA_ID_sequence::const_iterator DATA_ID_const_iterator;
  typedef ::xsd::cxx::tree::traits< DATA_ID_type, char > DATA_ID_traits;

  const DATA_ID_sequence&
  DATA_ID () const;

  DATA_ID_sequence&
  DATA_ID ();

  void
  DATA_ID (const DATA_ID_sequence& s);

  // REF
  //
  typedef ::xml_schema::string REF_type;
  typedef ::xsd::cxx::tree::sequence< REF_type > REF_sequence;
  typedef REF_sequence::iterator REF_iterator;
  typedef REF_sequence::const_iterator REF_const_iterator;
  typedef ::xsd::cxx::tree::traits< REF_type, char > REF_traits;

  const REF_sequence&
  REF () const;

  REF_sequence&
  REF ();

  void
  REF (const REF_sequence& s);

  // RANG
  //
  typedef ::xml_schema::unsigned_byte RANG_type;
  typedef ::xsd::cxx::tree::sequence< RANG_type > RANG_sequence;
  typedef RANG_sequence::iterator RANG_iterator;
  typedef RANG_sequence::const_iterator RANG_const_iterator;
  typedef ::xsd::cxx::tree::traits< RANG_type, char > RANG_traits;

  const RANG_sequence&
  RANG () const;

  RANG_sequence&
  RANG ();

  void
  RANG (const RANG_sequence& s);

  // TYPE
  //
  typedef ::DATATypeTYPE TYPE_type;
  typedef ::xsd::cxx::tree::sequence< TYPE_type > TYPE_sequence;
  typedef TYPE_sequence::iterator TYPE_iterator;
  typedef TYPE_sequence::const_iterator TYPE_const_iterator;
  typedef ::xsd::cxx::tree::traits< TYPE_type, char > TYPE_traits;

  const TYPE_sequence&
  TYPE () const;

  TYPE_sequence&
  TYPE ();

  void
  TYPE (const TYPE_sequence& s);

  // INFO
  //
  typedef ::xml_schema::string INFO_type;
  typedef ::xsd::cxx::tree::sequence< INFO_type > INFO_sequence;
  typedef INFO_sequence::iterator INFO_iterator;
  typedef INFO_sequence::const_iterator INFO_const_iterator;
  typedef ::xsd::cxx::tree::traits< INFO_type, char > INFO_traits;

  const INFO_sequence&
  INFO () const;

  INFO_sequence&
  INFO ();

  void
  INFO (const INFO_sequence& s);

  // Define
  //
  typedef ::xml_schema::string Define_type;
  typedef ::xsd::cxx::tree::sequence< Define_type > Define_sequence;
  typedef Define_sequence::iterator Define_iterator;
  typedef Define_sequence::const_iterator Define_const_iterator;
  typedef ::xsd::cxx::tree::traits< Define_type, char > Define_traits;

  const Define_sequence&
  Define () const;

  Define_sequence&
  Define ();

  void
  Define (const Define_sequence& s);

  // VALUE_RAW
  //
  typedef ::xml_schema::string VALUE_RAW_type;
  typedef ::xsd::cxx::tree::sequence< VALUE_RAW_type > VALUE_RAW_sequence;
  typedef VALUE_RAW_sequence::iterator VALUE_RAW_iterator;
  typedef VALUE_RAW_sequence::const_iterator VALUE_RAW_const_iterator;
  typedef ::xsd::cxx::tree::traits< VALUE_RAW_type, char > VALUE_RAW_traits;

  const VALUE_RAW_sequence&
  VALUE_RAW () const;

  VALUE_RAW_sequence&
  VALUE_RAW ();

  void
  VALUE_RAW (const VALUE_RAW_sequence& s);

  // VALUE_SYS
  //
  typedef ::xml_schema::string VALUE_SYS_type;
  typedef ::xsd::cxx::tree::sequence< VALUE_SYS_type > VALUE_SYS_sequence;
  typedef VALUE_SYS_sequence::iterator VALUE_SYS_iterator;
  typedef VALUE_SYS_sequence::const_iterator VALUE_SYS_const_iterator;
  typedef ::xsd::cxx::tree::traits< VALUE_SYS_type, char > VALUE_SYS_traits;

  const VALUE_SYS_sequence&
  VALUE_SYS () const;

  VALUE_SYS_sequence&
  VALUE_SYS ();

  void
  VALUE_SYS (const VALUE_SYS_sequence& s);

  // Constructors.
  //
  DATAType ();

  DATAType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  DATAType (const DATAType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual DATAType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  DATAType&
  operator= (const DATAType& x);

  virtual 
  ~DATAType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DATA_ID_sequence DATA_ID_;
  REF_sequence REF_;
  RANG_sequence RANG_;
  TYPE_sequence TYPE_;
  INFO_sequence INFO_;
  Define_sequence Define_;
  VALUE_RAW_sequence VALUE_RAW_;
  VALUE_SYS_sequence VALUE_SYS_;
};

class DATA_SETType: public ::xml_schema::type
{
  public:
  // DATA_FORMAT
  //
  typedef ::xml_schema::string DATA_FORMAT_type;
  typedef ::xsd::cxx::tree::optional< DATA_FORMAT_type > DATA_FORMAT_optional;
  typedef ::xsd::cxx::tree::traits< DATA_FORMAT_type, char > DATA_FORMAT_traits;

  const DATA_FORMAT_optional&
  DATA_FORMAT () const;

  DATA_FORMAT_optional&
  DATA_FORMAT ();

  void
  DATA_FORMAT (const DATA_FORMAT_type& x);

  void
  DATA_FORMAT (const DATA_FORMAT_optional& x);

  void
  DATA_FORMAT (::std::auto_ptr< DATA_FORMAT_type > p);

  // REF_PARSE_DATA
  //
  typedef ::xml_schema::string REF_PARSE_DATA_type;
  typedef ::xsd::cxx::tree::optional< REF_PARSE_DATA_type > REF_PARSE_DATA_optional;
  typedef ::xsd::cxx::tree::traits< REF_PARSE_DATA_type, char > REF_PARSE_DATA_traits;

  const REF_PARSE_DATA_optional&
  REF_PARSE_DATA () const;

  REF_PARSE_DATA_optional&
  REF_PARSE_DATA ();

  void
  REF_PARSE_DATA (const REF_PARSE_DATA_type& x);

  void
  REF_PARSE_DATA (const REF_PARSE_DATA_optional& x);

  void
  REF_PARSE_DATA (::std::auto_ptr< REF_PARSE_DATA_type > p);

  // RAW
  //
  typedef ::xml_schema::string RAW_type;
  typedef ::xsd::cxx::tree::traits< RAW_type, char > RAW_traits;

  const RAW_type&
  RAW () const;

  RAW_type&
  RAW ();

  void
  RAW (const RAW_type& x);

  void
  RAW (::std::auto_ptr< RAW_type > p);

  // DATA
  //
  typedef ::DATAType DATA_type;
  typedef ::xsd::cxx::tree::sequence< DATA_type > DATA_sequence;
  typedef DATA_sequence::iterator DATA_iterator;
  typedef DATA_sequence::const_iterator DATA_const_iterator;
  typedef ::xsd::cxx::tree::traits< DATA_type, char > DATA_traits;

  const DATA_sequence&
  DATA () const;

  DATA_sequence&
  DATA ();

  void
  DATA (const DATA_sequence& s);

  // Constructors.
  //
  DATA_SETType (const RAW_type&);

  DATA_SETType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  DATA_SETType (const DATA_SETType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual DATA_SETType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  DATA_SETType&
  operator= (const DATA_SETType& x);

  virtual 
  ~DATA_SETType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DATA_FORMAT_optional DATA_FORMAT_;
  REF_PARSE_DATA_optional REF_PARSE_DATA_;
  ::xsd::cxx::tree::one< RAW_type > RAW_;
  DATA_sequence DATA_;
};

class FRAMEType: public ::xml_schema::type
{
  public:
  // IDENTIFIANT
  //
  typedef ::FRAMETypeIDENTIFIANT IDENTIFIANT_type;
  typedef ::xsd::cxx::tree::traits< IDENTIFIANT_type, char > IDENTIFIANT_traits;

  const IDENTIFIANT_type&
  IDENTIFIANT () const;

  IDENTIFIANT_type&
  IDENTIFIANT ();

  void
  IDENTIFIANT (const IDENTIFIANT_type& x);

  void
  IDENTIFIANT (::std::auto_ptr< IDENTIFIANT_type > p);

  // NOM
  //
  typedef ::FRAMETypeNOM NOM_type;
  typedef ::xsd::cxx::tree::traits< NOM_type, char > NOM_traits;

  const NOM_type&
  NOM () const;

  NOM_type&
  NOM ();

  void
  NOM (const NOM_type& x);

  void
  NOM (::std::auto_ptr< NOM_type > p);

  // SOURCE
  //
  typedef ::FRAMETypeSOURCE SOURCE_type;
  typedef ::xsd::cxx::tree::traits< SOURCE_type, char > SOURCE_traits;

  const SOURCE_type&
  SOURCE () const;

  SOURCE_type&
  SOURCE ();

  void
  SOURCE (const SOURCE_type& x);

  void
  SOURCE (::std::auto_ptr< SOURCE_type > p);

  // DESTINATION
  //
  typedef ::FRAMETypeDESTINATION DESTINATION_type;
  typedef ::xsd::cxx::tree::traits< DESTINATION_type, char > DESTINATION_traits;

  const DESTINATION_type&
  DESTINATION () const;

  DESTINATION_type&
  DESTINATION ();

  void
  DESTINATION (const DESTINATION_type& x);

  void
  DESTINATION (::std::auto_ptr< DESTINATION_type > p);

  // TIMESTAMP
  //
  typedef ::xml_schema::string TIMESTAMP_type;
  typedef ::xsd::cxx::tree::traits< TIMESTAMP_type, char > TIMESTAMP_traits;

  const TIMESTAMP_type&
  TIMESTAMP () const;

  TIMESTAMP_type&
  TIMESTAMP ();

  void
  TIMESTAMP (const TIMESTAMP_type& x);

  void
  TIMESTAMP (::std::auto_ptr< TIMESTAMP_type > p);

  // RAW
  //
  typedef ::xml_schema::string RAW_type;
  typedef ::xsd::cxx::tree::traits< RAW_type, char > RAW_traits;

  const RAW_type&
  RAW () const;

  RAW_type&
  RAW ();

  void
  RAW (const RAW_type& x);

  void
  RAW (::std::auto_ptr< RAW_type > p);

  // TYPE
  //
  typedef ::FRAMETypeTYPE TYPE_type;
  typedef ::xsd::cxx::tree::traits< TYPE_type, char > TYPE_traits;

  const TYPE_type&
  TYPE () const;

  TYPE_type&
  TYPE ();

  void
  TYPE (const TYPE_type& x);

  void
  TYPE (::std::auto_ptr< TYPE_type > p);

  // FRAME_NUMBER
  //
  typedef ::FRAMETypeFRAME_NUMBER FRAME_NUMBER_type;
  typedef ::xsd::cxx::tree::traits< FRAME_NUMBER_type, char > FRAME_NUMBER_traits;

  const FRAME_NUMBER_type&
  FRAME_NUMBER () const;

  FRAME_NUMBER_type&
  FRAME_NUMBER ();

  void
  FRAME_NUMBER (const FRAME_NUMBER_type& x);

  void
  FRAME_NUMBER (::std::auto_ptr< FRAME_NUMBER_type > p);

  // FRAME_PROTOCOL
  //
  typedef ::xml_schema::string FRAME_PROTOCOL_type;
  typedef ::xsd::cxx::tree::traits< FRAME_PROTOCOL_type, char > FRAME_PROTOCOL_traits;

  const FRAME_PROTOCOL_type&
  FRAME_PROTOCOL () const;

  FRAME_PROTOCOL_type&
  FRAME_PROTOCOL ();

  void
  FRAME_PROTOCOL (const FRAME_PROTOCOL_type& x);

  void
  FRAME_PROTOCOL (::std::auto_ptr< FRAME_PROTOCOL_type > p);

  // IP_PROTOCOL
  //
  typedef ::IP_PROTOCOLType IP_PROTOCOL_type;
  typedef ::xsd::cxx::tree::traits< IP_PROTOCOL_type, char > IP_PROTOCOL_traits;

  const IP_PROTOCOL_type&
  IP_PROTOCOL () const;

  IP_PROTOCOL_type&
  IP_PROTOCOL ();

  void
  IP_PROTOCOL (const IP_PROTOCOL_type& x);

  void
  IP_PROTOCOL (::std::auto_ptr< IP_PROTOCOL_type > p);

  // TRANSMISSION_PROTOCOL
  //
  typedef ::TRANSMISSION_PROTOCOLType TRANSMISSION_PROTOCOL_type;
  typedef ::xsd::cxx::tree::traits< TRANSMISSION_PROTOCOL_type, char > TRANSMISSION_PROTOCOL_traits;

  const TRANSMISSION_PROTOCOL_type&
  TRANSMISSION_PROTOCOL () const;

  TRANSMISSION_PROTOCOL_type&
  TRANSMISSION_PROTOCOL ();

  void
  TRANSMISSION_PROTOCOL (const TRANSMISSION_PROTOCOL_type& x);

  void
  TRANSMISSION_PROTOCOL (::std::auto_ptr< TRANSMISSION_PROTOCOL_type > p);

  // DATA_SET
  //
  typedef ::DATA_SETType DATA_SET_type;
  typedef ::xsd::cxx::tree::traits< DATA_SET_type, char > DATA_SET_traits;

  const DATA_SET_type&
  DATA_SET () const;

  DATA_SET_type&
  DATA_SET ();

  void
  DATA_SET (const DATA_SET_type& x);

  void
  DATA_SET (::std::auto_ptr< DATA_SET_type > p);

  // Constructors.
  //
  FRAMEType (const IDENTIFIANT_type&,
             const NOM_type&,
             const SOURCE_type&,
             const DESTINATION_type&,
             const TIMESTAMP_type&,
             const RAW_type&,
             const TYPE_type&,
             const FRAME_NUMBER_type&,
             const FRAME_PROTOCOL_type&,
             const IP_PROTOCOL_type&,
             const TRANSMISSION_PROTOCOL_type&,
             const DATA_SET_type&);

  FRAMEType (const IDENTIFIANT_type&,
             const NOM_type&,
             const SOURCE_type&,
             const DESTINATION_type&,
             const TIMESTAMP_type&,
             const RAW_type&,
             const TYPE_type&,
             const FRAME_NUMBER_type&,
             const FRAME_PROTOCOL_type&,
             ::std::auto_ptr< IP_PROTOCOL_type >,
             ::std::auto_ptr< TRANSMISSION_PROTOCOL_type >,
             ::std::auto_ptr< DATA_SET_type >);

  FRAMEType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  FRAMEType (const FRAMEType& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual FRAMEType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  FRAMEType&
  operator= (const FRAMEType& x);

  virtual 
  ~FRAMEType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< IDENTIFIANT_type > IDENTIFIANT_;
  ::xsd::cxx::tree::one< NOM_type > NOM_;
  ::xsd::cxx::tree::one< SOURCE_type > SOURCE_;
  ::xsd::cxx::tree::one< DESTINATION_type > DESTINATION_;
  ::xsd::cxx::tree::one< TIMESTAMP_type > TIMESTAMP_;
  ::xsd::cxx::tree::one< RAW_type > RAW_;
  ::xsd::cxx::tree::one< TYPE_type > TYPE_;
  ::xsd::cxx::tree::one< FRAME_NUMBER_type > FRAME_NUMBER_;
  ::xsd::cxx::tree::one< FRAME_PROTOCOL_type > FRAME_PROTOCOL_;
  ::xsd::cxx::tree::one< IP_PROTOCOL_type > IP_PROTOCOL_;
  ::xsd::cxx::tree::one< TRANSMISSION_PROTOCOL_type > TRANSMISSION_PROTOCOL_;
  ::xsd::cxx::tree::one< DATA_SET_type > DATA_SET_;
};

class OUTPUTType: public ::xml_schema::type
{
  public:
  // TEST_REF
  //
  typedef ::TEST_REFType TEST_REF_type;
  typedef ::xsd::cxx::tree::traits< TEST_REF_type, char > TEST_REF_traits;

  const TEST_REF_type&
  TEST_REF () const;

  TEST_REF_type&
  TEST_REF ();

  void
  TEST_REF (const TEST_REF_type& x);

  void
  TEST_REF (::std::auto_ptr< TEST_REF_type > p);

  // TOOL_CFG
  //
  typedef ::TOOL_CFGType TOOL_CFG_type;
  typedef ::xsd::cxx::tree::traits< TOOL_CFG_type, char > TOOL_CFG_traits;

  const TOOL_CFG_type&
  TOOL_CFG () const;

  TOOL_CFG_type&
  TOOL_CFG ();

  void
  TOOL_CFG (const TOOL_CFG_type& x);

  void
  TOOL_CFG (::std::auto_ptr< TOOL_CFG_type > p);

  // FRAME
  //
  typedef ::FRAMEType FRAME_type;
  typedef ::xsd::cxx::tree::sequence< FRAME_type > FRAME_sequence;
  typedef FRAME_sequence::iterator FRAME_iterator;
  typedef FRAME_sequence::const_iterator FRAME_const_iterator;
  typedef ::xsd::cxx::tree::traits< FRAME_type, char > FRAME_traits;

  const FRAME_sequence&
  FRAME () const;

  FRAME_sequence&
  FRAME ();

  void
  FRAME (const FRAME_sequence& s);

  // Constructors.
  //
  OUTPUTType (const TEST_REF_type&,
              const TOOL_CFG_type&);

  OUTPUTType (::std::auto_ptr< TEST_REF_type >,
              ::std::auto_ptr< TOOL_CFG_type >);

  OUTPUTType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  OUTPUTType (const OUTPUTType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual OUTPUTType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  OUTPUTType&
  operator= (const OUTPUTType& x);

  virtual 
  ~OUTPUTType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< TEST_REF_type > TEST_REF_;
  ::xsd::cxx::tree::one< TOOL_CFG_type > TOOL_CFG_;
  FRAME_sequence FRAME_;
};

class BDD_OUTPUT_DATAType: public ::xml_schema::type
{
  public:
  // OUTPUT
  //
  typedef ::OUTPUTType OUTPUT_type;
  typedef ::xsd::cxx::tree::traits< OUTPUT_type, char > OUTPUT_traits;

  const OUTPUT_type&
  OUTPUT () const;

  OUTPUT_type&
  OUTPUT ();

  void
  OUTPUT (const OUTPUT_type& x);

  void
  OUTPUT (::std::auto_ptr< OUTPUT_type > p);

  // Constructors.
  //
  BDD_OUTPUT_DATAType (const OUTPUT_type&);

  BDD_OUTPUT_DATAType (::std::auto_ptr< OUTPUT_type >);

  BDD_OUTPUT_DATAType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  BDD_OUTPUT_DATAType (const BDD_OUTPUT_DATAType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual BDD_OUTPUT_DATAType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  BDD_OUTPUT_DATAType&
  operator= (const BDD_OUTPUT_DATAType& x);

  virtual 
  ~BDD_OUTPUT_DATAType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< OUTPUT_type > OUTPUT_;
};

class DATATypeTYPE: public ::xml_schema::string
{
  public:
  enum value
  {
    UINT16,
    BIT,
    HM
  };

  DATATypeTYPE (value v);

  DATATypeTYPE (const char* v);

  DATATypeTYPE (const ::std::string& v);

  DATATypeTYPE (const ::xml_schema::string& v);

  DATATypeTYPE (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  DATATypeTYPE (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  DATATypeTYPE (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  DATATypeTYPE (const DATATypeTYPE& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual DATATypeTYPE*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  DATATypeTYPE&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_DATATypeTYPE_convert ();
  }

  protected:
  value
  _xsd_DATATypeTYPE_convert () const;

  public:
  static const char* const _xsd_DATATypeTYPE_literals_[3];
  static const value _xsd_DATATypeTYPE_indexes_[3];
};

class FRAMETypeIDENTIFIANT: public ::xml_schema::string
{
  public:
  enum value
  {
    SNBISUGO1_SNBISMOD1_Mod_P,
    SNBISMOD1_Mod_P_SNBISUGO1
  };

  FRAMETypeIDENTIFIANT (value v);

  FRAMETypeIDENTIFIANT (const char* v);

  FRAMETypeIDENTIFIANT (const ::std::string& v);

  FRAMETypeIDENTIFIANT (const ::xml_schema::string& v);

  FRAMETypeIDENTIFIANT (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  FRAMETypeIDENTIFIANT (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  FRAMETypeIDENTIFIANT (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  FRAMETypeIDENTIFIANT (const FRAMETypeIDENTIFIANT& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual FRAMETypeIDENTIFIANT*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  FRAMETypeIDENTIFIANT&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_FRAMETypeIDENTIFIANT_convert ();
  }

  protected:
  value
  _xsd_FRAMETypeIDENTIFIANT_convert () const;

  public:
  static const char* const _xsd_FRAMETypeIDENTIFIANT_literals_[2];
  static const value _xsd_FRAMETypeIDENTIFIANT_indexes_[2];
};

class FRAMETypeNOM: public ::xml_schema::string
{
  public:
  enum value
  {
    UGO_1_BIS_vers_MOD_1_BIS,
    MOD_1_BIS_vers_UGO_1_BIS
  };

  FRAMETypeNOM (value v);

  FRAMETypeNOM (const char* v);

  FRAMETypeNOM (const ::std::string& v);

  FRAMETypeNOM (const ::xml_schema::string& v);

  FRAMETypeNOM (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  FRAMETypeNOM (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  FRAMETypeNOM (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  FRAMETypeNOM (const FRAMETypeNOM& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual FRAMETypeNOM*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  FRAMETypeNOM&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_FRAMETypeNOM_convert ();
  }

  protected:
  value
  _xsd_FRAMETypeNOM_convert () const;

  public:
  static const char* const _xsd_FRAMETypeNOM_literals_[2];
  static const value _xsd_FRAMETypeNOM_indexes_[2];
};

class FRAMETypeSOURCE: public ::xml_schema::string
{
  public:
  enum value
  {
    SNBISUGO1_CPU_P,
    SNBISMOD1_Mod
  };

  FRAMETypeSOURCE (value v);

  FRAMETypeSOURCE (const char* v);

  FRAMETypeSOURCE (const ::std::string& v);

  FRAMETypeSOURCE (const ::xml_schema::string& v);

  FRAMETypeSOURCE (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  FRAMETypeSOURCE (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  FRAMETypeSOURCE (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  FRAMETypeSOURCE (const FRAMETypeSOURCE& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual FRAMETypeSOURCE*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  FRAMETypeSOURCE&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_FRAMETypeSOURCE_convert ();
  }

  protected:
  value
  _xsd_FRAMETypeSOURCE_convert () const;

  public:
  static const char* const _xsd_FRAMETypeSOURCE_literals_[2];
  static const value _xsd_FRAMETypeSOURCE_indexes_[2];
};

class FRAMETypeDESTINATION: public ::xml_schema::string
{
  public:
  enum value
  {
    SNBISMOD1_Mod,
    SNBISUGO1_CPU_P
  };

  FRAMETypeDESTINATION (value v);

  FRAMETypeDESTINATION (const char* v);

  FRAMETypeDESTINATION (const ::std::string& v);

  FRAMETypeDESTINATION (const ::xml_schema::string& v);

  FRAMETypeDESTINATION (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  FRAMETypeDESTINATION (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  FRAMETypeDESTINATION (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  FRAMETypeDESTINATION (const FRAMETypeDESTINATION& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual FRAMETypeDESTINATION*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  FRAMETypeDESTINATION&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_FRAMETypeDESTINATION_convert ();
  }

  protected:
  value
  _xsd_FRAMETypeDESTINATION_convert () const;

  public:
  static const char* const _xsd_FRAMETypeDESTINATION_literals_[2];
  static const value _xsd_FRAMETypeDESTINATION_indexes_[2];
};

class FRAMETypeTYPE: public ::xml_schema::string
{
  public:
  enum value
  {
    QUERY,
    RESPONSE
  };

  FRAMETypeTYPE (value v);

  FRAMETypeTYPE (const char* v);

  FRAMETypeTYPE (const ::std::string& v);

  FRAMETypeTYPE (const ::xml_schema::string& v);

  FRAMETypeTYPE (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  FRAMETypeTYPE (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  FRAMETypeTYPE (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  FRAMETypeTYPE (const FRAMETypeTYPE& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual FRAMETypeTYPE*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  FRAMETypeTYPE&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_FRAMETypeTYPE_convert ();
  }

  protected:
  value
  _xsd_FRAMETypeTYPE_convert () const;

  public:
  static const char* const _xsd_FRAMETypeTYPE_literals_[2];
  static const value _xsd_FRAMETypeTYPE_indexes_[2];
};

class FRAMETypeFRAME_NUMBER: public ::xml_schema::string
{
  public:
  enum value
  {
    cxx_76,
    cxx_234
  };

  FRAMETypeFRAME_NUMBER (value v);

  FRAMETypeFRAME_NUMBER (const char* v);

  FRAMETypeFRAME_NUMBER (const ::std::string& v);

  FRAMETypeFRAME_NUMBER (const ::xml_schema::string& v);

  FRAMETypeFRAME_NUMBER (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  FRAMETypeFRAME_NUMBER (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  FRAMETypeFRAME_NUMBER (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  FRAMETypeFRAME_NUMBER (const FRAMETypeFRAME_NUMBER& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual FRAMETypeFRAME_NUMBER*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  FRAMETypeFRAME_NUMBER&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_FRAMETypeFRAME_NUMBER_convert ();
  }

  protected:
  value
  _xsd_FRAMETypeFRAME_NUMBER_convert () const;

  public:
  static const char* const _xsd_FRAMETypeFRAME_NUMBER_literals_[2];
  static const value _xsd_FRAMETypeFRAME_NUMBER_indexes_[2];
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (const ::std::string& uri,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (const ::std::string& uri,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (const ::std::string& uri,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::std::istream& is,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::std::istream& is,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::std::istream& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::std::istream& is,
                 const ::std::string& id,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::xercesc::InputSource& is,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::xercesc::InputSource& is,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::xercesc::InputSource& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

// Serialize to std::ostream.
//

void
BDD_OUTPUT_DATA (::std::ostream& os,
                 const ::BDD_OUTPUT_DATAType& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

void
BDD_OUTPUT_DATA (::std::ostream& os,
                 const ::BDD_OUTPUT_DATAType& x, 
                 ::xml_schema::error_handler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

void
BDD_OUTPUT_DATA (::std::ostream& os,
                 const ::BDD_OUTPUT_DATAType& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
BDD_OUTPUT_DATA (::xercesc::XMLFormatTarget& ft,
                 const ::BDD_OUTPUT_DATAType& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

void
BDD_OUTPUT_DATA (::xercesc::XMLFormatTarget& ft,
                 const ::BDD_OUTPUT_DATAType& x, 
                 ::xml_schema::error_handler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

void
BDD_OUTPUT_DATA (::xercesc::XMLFormatTarget& ft,
                 const ::BDD_OUTPUT_DATAType& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
BDD_OUTPUT_DATA (::xercesc::DOMDocument& d,
                 const ::BDD_OUTPUT_DATAType& x,
                 ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
BDD_OUTPUT_DATA (const ::BDD_OUTPUT_DATAType& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const EXIGENCESType&);

void
operator<< (::xercesc::DOMElement&, const LOGICIELType&);

void
operator<< (::xercesc::DOMElement&, const MATERIELType&);

void
operator<< (::xercesc::DOMElement&, const CONFIGURATIONType&);

void
operator<< (::xercesc::DOMElement&, const TEST_REFType&);

void
operator<< (::xercesc::DOMElement&, const FILESType&);

void
operator<< (::xercesc::DOMElement&, const TOOL_CFGType&);

void
operator<< (::xercesc::DOMElement&, const IP_PROTOCOLType&);

void
operator<< (::xercesc::DOMElement&, const TRANSMISSION_PROTOCOLType&);

void
operator<< (::xercesc::DOMElement&, const DATAType&);

void
operator<< (::xercesc::DOMElement&, const DATA_SETType&);

void
operator<< (::xercesc::DOMElement&, const FRAMEType&);

void
operator<< (::xercesc::DOMElement&, const OUTPUTType&);

void
operator<< (::xercesc::DOMElement&, const BDD_OUTPUT_DATAType&);

void
operator<< (::xercesc::DOMElement&, const DATATypeTYPE&);

void
operator<< (::xercesc::DOMAttr&, const DATATypeTYPE&);

void
operator<< (::xml_schema::list_stream&,
            const DATATypeTYPE&);

void
operator<< (::xercesc::DOMElement&, const FRAMETypeIDENTIFIANT&);

void
operator<< (::xercesc::DOMAttr&, const FRAMETypeIDENTIFIANT&);

void
operator<< (::xml_schema::list_stream&,
            const FRAMETypeIDENTIFIANT&);

void
operator<< (::xercesc::DOMElement&, const FRAMETypeNOM&);

void
operator<< (::xercesc::DOMAttr&, const FRAMETypeNOM&);

void
operator<< (::xml_schema::list_stream&,
            const FRAMETypeNOM&);

void
operator<< (::xercesc::DOMElement&, const FRAMETypeSOURCE&);

void
operator<< (::xercesc::DOMAttr&, const FRAMETypeSOURCE&);

void
operator<< (::xml_schema::list_stream&,
            const FRAMETypeSOURCE&);

void
operator<< (::xercesc::DOMElement&, const FRAMETypeDESTINATION&);

void
operator<< (::xercesc::DOMAttr&, const FRAMETypeDESTINATION&);

void
operator<< (::xml_schema::list_stream&,
            const FRAMETypeDESTINATION&);

void
operator<< (::xercesc::DOMElement&, const FRAMETypeTYPE&);

void
operator<< (::xercesc::DOMAttr&, const FRAMETypeTYPE&);

void
operator<< (::xml_schema::list_stream&,
            const FRAMETypeTYPE&);

void
operator<< (::xercesc::DOMElement&, const FRAMETypeFRAME_NUMBER&);

void
operator<< (::xercesc::DOMAttr&, const FRAMETypeFRAME_NUMBER&);

void
operator<< (::xml_schema::list_stream&,
            const FRAMETypeFRAME_NUMBER&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // C__D_SAFRAN_STROMBOLI_SVN_STROMBOLI_XSD_TRACE_SORTIE_HXX
