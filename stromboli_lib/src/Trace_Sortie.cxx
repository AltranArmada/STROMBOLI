// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Trace_Sortie.hxx"

// EXIGENCESType
// 

const EXIGENCESType::ID_EXI_sequence& EXIGENCESType::
ID_EXI () const
{
  return this->ID_EXI_;
}

EXIGENCESType::ID_EXI_sequence& EXIGENCESType::
ID_EXI ()
{
  return this->ID_EXI_;
}

void EXIGENCESType::
ID_EXI (const ID_EXI_sequence& s)
{
  this->ID_EXI_ = s;
}


// LOGICIELType
// 

const LOGICIELType::SSG_type& LOGICIELType::
SSG () const
{
  return this->SSG_.get ();
}

LOGICIELType::SSG_type& LOGICIELType::
SSG ()
{
  return this->SSG_.get ();
}

void LOGICIELType::
SSG (const SSG_type& x)
{
  this->SSG_.set (x);
}

void LOGICIELType::
SSG (::std::auto_ptr< SSG_type > x)
{
  this->SSG_.set (x);
}

const LOGICIELType::SST_type& LOGICIELType::
SST () const
{
  return this->SST_.get ();
}

LOGICIELType::SST_type& LOGICIELType::
SST ()
{
  return this->SST_.get ();
}

void LOGICIELType::
SST (const SST_type& x)
{
  this->SST_.set (x);
}

void LOGICIELType::
SST (::std::auto_ptr< SST_type > x)
{
  this->SST_.set (x);
}


// MATERIELType
// 

const MATERIELType::SSG_type& MATERIELType::
SSG () const
{
  return this->SSG_.get ();
}

MATERIELType::SSG_type& MATERIELType::
SSG ()
{
  return this->SSG_.get ();
}

void MATERIELType::
SSG (const SSG_type& x)
{
  this->SSG_.set (x);
}

void MATERIELType::
SSG (::std::auto_ptr< SSG_type > x)
{
  this->SSG_.set (x);
}

const MATERIELType::SST_type& MATERIELType::
SST () const
{
  return this->SST_.get ();
}

MATERIELType::SST_type& MATERIELType::
SST ()
{
  return this->SST_.get ();
}

void MATERIELType::
SST (const SST_type& x)
{
  this->SST_.set (x);
}

void MATERIELType::
SST (::std::auto_ptr< SST_type > x)
{
  this->SST_.set (x);
}


// CONFIGURATIONType
// 

const CONFIGURATIONType::LOGICIEL_type& CONFIGURATIONType::
LOGICIEL () const
{
  return this->LOGICIEL_.get ();
}

CONFIGURATIONType::LOGICIEL_type& CONFIGURATIONType::
LOGICIEL ()
{
  return this->LOGICIEL_.get ();
}

void CONFIGURATIONType::
LOGICIEL (const LOGICIEL_type& x)
{
  this->LOGICIEL_.set (x);
}

void CONFIGURATIONType::
LOGICIEL (::std::auto_ptr< LOGICIEL_type > x)
{
  this->LOGICIEL_.set (x);
}

const CONFIGURATIONType::MATERIEL_type& CONFIGURATIONType::
MATERIEL () const
{
  return this->MATERIEL_.get ();
}

CONFIGURATIONType::MATERIEL_type& CONFIGURATIONType::
MATERIEL ()
{
  return this->MATERIEL_.get ();
}

void CONFIGURATIONType::
MATERIEL (const MATERIEL_type& x)
{
  this->MATERIEL_.set (x);
}

void CONFIGURATIONType::
MATERIEL (::std::auto_ptr< MATERIEL_type > x)
{
  this->MATERIEL_.set (x);
}


// TEST_REFType
// 

const TEST_REFType::TEST_ID_type& TEST_REFType::
TEST_ID () const
{
  return this->TEST_ID_.get ();
}

TEST_REFType::TEST_ID_type& TEST_REFType::
TEST_ID ()
{
  return this->TEST_ID_.get ();
}

void TEST_REFType::
TEST_ID (const TEST_ID_type& x)
{
  this->TEST_ID_.set (x);
}

void TEST_REFType::
TEST_ID (::std::auto_ptr< TEST_ID_type > x)
{
  this->TEST_ID_.set (x);
}

const TEST_REFType::ORIGINE_type& TEST_REFType::
ORIGINE () const
{
  return this->ORIGINE_.get ();
}

TEST_REFType::ORIGINE_type& TEST_REFType::
ORIGINE ()
{
  return this->ORIGINE_.get ();
}

void TEST_REFType::
ORIGINE (const ORIGINE_type& x)
{
  this->ORIGINE_.set (x);
}

void TEST_REFType::
ORIGINE (::std::auto_ptr< ORIGINE_type > x)
{
  this->ORIGINE_.set (x);
}

const TEST_REFType::TITRE_type& TEST_REFType::
TITRE () const
{
  return this->TITRE_.get ();
}

TEST_REFType::TITRE_type& TEST_REFType::
TITRE ()
{
  return this->TITRE_.get ();
}

void TEST_REFType::
TITRE (const TITRE_type& x)
{
  this->TITRE_.set (x);
}

void TEST_REFType::
TITRE (::std::auto_ptr< TITRE_type > x)
{
  this->TITRE_.set (x);
}

const TEST_REFType::REFERENCE_PROCEDURE_type& TEST_REFType::
REFERENCE_PROCEDURE () const
{
  return this->REFERENCE_PROCEDURE_.get ();
}

TEST_REFType::REFERENCE_PROCEDURE_type& TEST_REFType::
REFERENCE_PROCEDURE ()
{
  return this->REFERENCE_PROCEDURE_.get ();
}

void TEST_REFType::
REFERENCE_PROCEDURE (const REFERENCE_PROCEDURE_type& x)
{
  this->REFERENCE_PROCEDURE_.set (x);
}

void TEST_REFType::
REFERENCE_PROCEDURE (::std::auto_ptr< REFERENCE_PROCEDURE_type > x)
{
  this->REFERENCE_PROCEDURE_.set (x);
}

const TEST_REFType::VERSION_PROCEDURE_type& TEST_REFType::
VERSION_PROCEDURE () const
{
  return this->VERSION_PROCEDURE_.get ();
}

TEST_REFType::VERSION_PROCEDURE_type& TEST_REFType::
VERSION_PROCEDURE ()
{
  return this->VERSION_PROCEDURE_.get ();
}

void TEST_REFType::
VERSION_PROCEDURE (const VERSION_PROCEDURE_type& x)
{
  this->VERSION_PROCEDURE_.set (x);
}

void TEST_REFType::
VERSION_PROCEDURE (::std::auto_ptr< VERSION_PROCEDURE_type > x)
{
  this->VERSION_PROCEDURE_.set (x);
}

const TEST_REFType::SECTION_PROCEDURE_type& TEST_REFType::
SECTION_PROCEDURE () const
{
  return this->SECTION_PROCEDURE_.get ();
}

TEST_REFType::SECTION_PROCEDURE_type& TEST_REFType::
SECTION_PROCEDURE ()
{
  return this->SECTION_PROCEDURE_.get ();
}

void TEST_REFType::
SECTION_PROCEDURE (const SECTION_PROCEDURE_type& x)
{
  this->SECTION_PROCEDURE_.set (x);
}

void TEST_REFType::
SECTION_PROCEDURE (::std::auto_ptr< SECTION_PROCEDURE_type > x)
{
  this->SECTION_PROCEDURE_.set (x);
}

const TEST_REFType::EXIGENCES_type& TEST_REFType::
EXIGENCES () const
{
  return this->EXIGENCES_.get ();
}

TEST_REFType::EXIGENCES_type& TEST_REFType::
EXIGENCES ()
{
  return this->EXIGENCES_.get ();
}

void TEST_REFType::
EXIGENCES (const EXIGENCES_type& x)
{
  this->EXIGENCES_.set (x);
}

void TEST_REFType::
EXIGENCES (::std::auto_ptr< EXIGENCES_type > x)
{
  this->EXIGENCES_.set (x);
}

const TEST_REFType::CONFIGURATION_type& TEST_REFType::
CONFIGURATION () const
{
  return this->CONFIGURATION_.get ();
}

TEST_REFType::CONFIGURATION_type& TEST_REFType::
CONFIGURATION ()
{
  return this->CONFIGURATION_.get ();
}

void TEST_REFType::
CONFIGURATION (const CONFIGURATION_type& x)
{
  this->CONFIGURATION_.set (x);
}

void TEST_REFType::
CONFIGURATION (::std::auto_ptr< CONFIGURATION_type > x)
{
  this->CONFIGURATION_.set (x);
}

const TEST_REFType::DATE_type& TEST_REFType::
DATE () const
{
  return this->DATE_.get ();
}

TEST_REFType::DATE_type& TEST_REFType::
DATE ()
{
  return this->DATE_.get ();
}

void TEST_REFType::
DATE (const DATE_type& x)
{
  this->DATE_.set (x);
}

void TEST_REFType::
DATE (::std::auto_ptr< DATE_type > x)
{
  this->DATE_.set (x);
}

const TEST_REFType::HEURE_type& TEST_REFType::
HEURE () const
{
  return this->HEURE_.get ();
}

TEST_REFType::HEURE_type& TEST_REFType::
HEURE ()
{
  return this->HEURE_.get ();
}

void TEST_REFType::
HEURE (const HEURE_type& x)
{
  this->HEURE_.set (x);
}

void TEST_REFType::
HEURE (::std::auto_ptr< HEURE_type > x)
{
  this->HEURE_.set (x);
}

const TEST_REFType::LIEU_type& TEST_REFType::
LIEU () const
{
  return this->LIEU_.get ();
}

TEST_REFType::LIEU_type& TEST_REFType::
LIEU ()
{
  return this->LIEU_.get ();
}

void TEST_REFType::
LIEU (const LIEU_type& x)
{
  this->LIEU_.set (x);
}

void TEST_REFType::
LIEU (::std::auto_ptr< LIEU_type > x)
{
  this->LIEU_.set (x);
}

const TEST_REFType::OPERATEUR_type& TEST_REFType::
OPERATEUR () const
{
  return this->OPERATEUR_.get ();
}

TEST_REFType::OPERATEUR_type& TEST_REFType::
OPERATEUR ()
{
  return this->OPERATEUR_.get ();
}

void TEST_REFType::
OPERATEUR (const OPERATEUR_type& x)
{
  this->OPERATEUR_.set (x);
}

void TEST_REFType::
OPERATEUR (::std::auto_ptr< OPERATEUR_type > x)
{
  this->OPERATEUR_.set (x);
}

const TEST_REFType::COMMENT_type& TEST_REFType::
COMMENT () const
{
  return this->COMMENT_.get ();
}

TEST_REFType::COMMENT_type& TEST_REFType::
COMMENT ()
{
  return this->COMMENT_.get ();
}

void TEST_REFType::
COMMENT (const COMMENT_type& x)
{
  this->COMMENT_.set (x);
}

void TEST_REFType::
COMMENT (::std::auto_ptr< COMMENT_type > x)
{
  this->COMMENT_.set (x);
}

const TEST_REFType::VALIDITE_type& TEST_REFType::
VALIDITE () const
{
  return this->VALIDITE_.get ();
}

TEST_REFType::VALIDITE_type& TEST_REFType::
VALIDITE ()
{
  return this->VALIDITE_.get ();
}

void TEST_REFType::
VALIDITE (const VALIDITE_type& x)
{
  this->VALIDITE_.set (x);
}

void TEST_REFType::
VALIDITE (::std::auto_ptr< VALIDITE_type > x)
{
  this->VALIDITE_.set (x);
}

const TEST_REFType::SAUVEGARDE_type& TEST_REFType::
SAUVEGARDE () const
{
  return this->SAUVEGARDE_.get ();
}

TEST_REFType::SAUVEGARDE_type& TEST_REFType::
SAUVEGARDE ()
{
  return this->SAUVEGARDE_.get ();
}

void TEST_REFType::
SAUVEGARDE (const SAUVEGARDE_type& x)
{
  this->SAUVEGARDE_.set (x);
}

void TEST_REFType::
SAUVEGARDE (::std::auto_ptr< SAUVEGARDE_type > x)
{
  this->SAUVEGARDE_.set (x);
}


// FILESType
// 

const FILESType::CFG_IP_type& FILESType::
CFG_IP () const
{
  return this->CFG_IP_.get ();
}

FILESType::CFG_IP_type& FILESType::
CFG_IP ()
{
  return this->CFG_IP_.get ();
}

void FILESType::
CFG_IP (const CFG_IP_type& x)
{
  this->CFG_IP_.set (x);
}

void FILESType::
CFG_IP (::std::auto_ptr< CFG_IP_type > x)
{
  this->CFG_IP_.set (x);
}

const FILESType::CFG_FLUX_type& FILESType::
CFG_FLUX () const
{
  return this->CFG_FLUX_.get ();
}

FILESType::CFG_FLUX_type& FILESType::
CFG_FLUX ()
{
  return this->CFG_FLUX_.get ();
}

void FILESType::
CFG_FLUX (const CFG_FLUX_type& x)
{
  this->CFG_FLUX_.set (x);
}

void FILESType::
CFG_FLUX (::std::auto_ptr< CFG_FLUX_type > x)
{
  this->CFG_FLUX_.set (x);
}

const FILESType::CFG_DATA_type& FILESType::
CFG_DATA () const
{
  return this->CFG_DATA_.get ();
}

FILESType::CFG_DATA_type& FILESType::
CFG_DATA ()
{
  return this->CFG_DATA_.get ();
}

void FILESType::
CFG_DATA (const CFG_DATA_type& x)
{
  this->CFG_DATA_.set (x);
}

void FILESType::
CFG_DATA (::std::auto_ptr< CFG_DATA_type > x)
{
  this->CFG_DATA_.set (x);
}

const FILESType::CFG_DATA_VAL_type& FILESType::
CFG_DATA_VAL () const
{
  return this->CFG_DATA_VAL_.get ();
}

FILESType::CFG_DATA_VAL_type& FILESType::
CFG_DATA_VAL ()
{
  return this->CFG_DATA_VAL_.get ();
}

void FILESType::
CFG_DATA_VAL (const CFG_DATA_VAL_type& x)
{
  this->CFG_DATA_VAL_.set (x);
}

void FILESType::
CFG_DATA_VAL (::std::auto_ptr< CFG_DATA_VAL_type > x)
{
  this->CFG_DATA_VAL_.set (x);
}

const FILESType::CFG_TEST_type& FILESType::
CFG_TEST () const
{
  return this->CFG_TEST_.get ();
}

FILESType::CFG_TEST_type& FILESType::
CFG_TEST ()
{
  return this->CFG_TEST_.get ();
}

void FILESType::
CFG_TEST (const CFG_TEST_type& x)
{
  this->CFG_TEST_.set (x);
}

void FILESType::
CFG_TEST (::std::auto_ptr< CFG_TEST_type > x)
{
  this->CFG_TEST_.set (x);
}


// TOOL_CFGType
// 

const TOOL_CFGType::IDENT_type& TOOL_CFGType::
IDENT () const
{
  return this->IDENT_.get ();
}

TOOL_CFGType::IDENT_type& TOOL_CFGType::
IDENT ()
{
  return this->IDENT_.get ();
}

void TOOL_CFGType::
IDENT (const IDENT_type& x)
{
  this->IDENT_.set (x);
}

void TOOL_CFGType::
IDENT (::std::auto_ptr< IDENT_type > x)
{
  this->IDENT_.set (x);
}

const TOOL_CFGType::VERSION_type& TOOL_CFGType::
VERSION () const
{
  return this->VERSION_.get ();
}

TOOL_CFGType::VERSION_type& TOOL_CFGType::
VERSION ()
{
  return this->VERSION_.get ();
}

void TOOL_CFGType::
VERSION (const VERSION_type& x)
{
  this->VERSION_.set (x);
}

void TOOL_CFGType::
VERSION (::std::auto_ptr< VERSION_type > x)
{
  this->VERSION_.set (x);
}

const TOOL_CFGType::FILES_type& TOOL_CFGType::
FILES () const
{
  return this->FILES_.get ();
}

TOOL_CFGType::FILES_type& TOOL_CFGType::
FILES ()
{
  return this->FILES_.get ();
}

void TOOL_CFGType::
FILES (const FILES_type& x)
{
  this->FILES_.set (x);
}

void TOOL_CFGType::
FILES (::std::auto_ptr< FILES_type > x)
{
  this->FILES_.set (x);
}

const TOOL_CFGType::DATE_type& TOOL_CFGType::
DATE () const
{
  return this->DATE_.get ();
}

TOOL_CFGType::DATE_type& TOOL_CFGType::
DATE ()
{
  return this->DATE_.get ();
}

void TOOL_CFGType::
DATE (const DATE_type& x)
{
  this->DATE_.set (x);
}

void TOOL_CFGType::
DATE (::std::auto_ptr< DATE_type > x)
{
  this->DATE_.set (x);
}

const TOOL_CFGType::HEURE_type& TOOL_CFGType::
HEURE () const
{
  return this->HEURE_.get ();
}

TOOL_CFGType::HEURE_type& TOOL_CFGType::
HEURE ()
{
  return this->HEURE_.get ();
}

void TOOL_CFGType::
HEURE (const HEURE_type& x)
{
  this->HEURE_.set (x);
}

void TOOL_CFGType::
HEURE (::std::auto_ptr< HEURE_type > x)
{
  this->HEURE_.set (x);
}


// IP_PROTOCOLType
// 

const IP_PROTOCOLType::FLAGS_type& IP_PROTOCOLType::
FLAGS () const
{
  return this->FLAGS_.get ();
}

IP_PROTOCOLType::FLAGS_type& IP_PROTOCOLType::
FLAGS ()
{
  return this->FLAGS_.get ();
}

void IP_PROTOCOLType::
FLAGS (const FLAGS_type& x)
{
  this->FLAGS_.set (x);
}

void IP_PROTOCOLType::
FLAGS (::std::auto_ptr< FLAGS_type > x)
{
  this->FLAGS_.set (x);
}

const IP_PROTOCOLType::Header_CHECKSUM_type& IP_PROTOCOLType::
Header_CHECKSUM () const
{
  return this->Header_CHECKSUM_.get ();
}

IP_PROTOCOLType::Header_CHECKSUM_type& IP_PROTOCOLType::
Header_CHECKSUM ()
{
  return this->Header_CHECKSUM_.get ();
}

void IP_PROTOCOLType::
Header_CHECKSUM (const Header_CHECKSUM_type& x)
{
  this->Header_CHECKSUM_.set (x);
}

void IP_PROTOCOLType::
Header_CHECKSUM (::std::auto_ptr< Header_CHECKSUM_type > x)
{
  this->Header_CHECKSUM_.set (x);
}


// TRANSMISSION_PROTOCOLType
// 

const TRANSMISSION_PROTOCOLType::SEQ_NUMBER_type& TRANSMISSION_PROTOCOLType::
SEQ_NUMBER () const
{
  return this->SEQ_NUMBER_.get ();
}

TRANSMISSION_PROTOCOLType::SEQ_NUMBER_type& TRANSMISSION_PROTOCOLType::
SEQ_NUMBER ()
{
  return this->SEQ_NUMBER_.get ();
}

void TRANSMISSION_PROTOCOLType::
SEQ_NUMBER (const SEQ_NUMBER_type& x)
{
  this->SEQ_NUMBER_.set (x);
}

const TRANSMISSION_PROTOCOLType::ACK_RTT_type& TRANSMISSION_PROTOCOLType::
ACK_RTT () const
{
  return this->ACK_RTT_.get ();
}

TRANSMISSION_PROTOCOLType::ACK_RTT_type& TRANSMISSION_PROTOCOLType::
ACK_RTT ()
{
  return this->ACK_RTT_.get ();
}

void TRANSMISSION_PROTOCOLType::
ACK_RTT (const ACK_RTT_type& x)
{
  this->ACK_RTT_.set (x);
}

void TRANSMISSION_PROTOCOLType::
ACK_RTT (::std::auto_ptr< ACK_RTT_type > x)
{
  this->ACK_RTT_.set (x);
}

const TRANSMISSION_PROTOCOLType::FLAGS_type& TRANSMISSION_PROTOCOLType::
FLAGS () const
{
  return this->FLAGS_.get ();
}

TRANSMISSION_PROTOCOLType::FLAGS_type& TRANSMISSION_PROTOCOLType::
FLAGS ()
{
  return this->FLAGS_.get ();
}

void TRANSMISSION_PROTOCOLType::
FLAGS (const FLAGS_type& x)
{
  this->FLAGS_.set (x);
}

void TRANSMISSION_PROTOCOLType::
FLAGS (::std::auto_ptr< FLAGS_type > x)
{
  this->FLAGS_.set (x);
}


// DATAType
// 

const DATAType::DATA_ID_sequence& DATAType::
DATA_ID () const
{
  return this->DATA_ID_;
}

DATAType::DATA_ID_sequence& DATAType::
DATA_ID ()
{
  return this->DATA_ID_;
}

void DATAType::
DATA_ID (const DATA_ID_sequence& s)
{
  this->DATA_ID_ = s;
}

const DATAType::REF_sequence& DATAType::
REF () const
{
  return this->REF_;
}

DATAType::REF_sequence& DATAType::
REF ()
{
  return this->REF_;
}

void DATAType::
REF (const REF_sequence& s)
{
  this->REF_ = s;
}

const DATAType::RANG_sequence& DATAType::
RANG () const
{
  return this->RANG_;
}

DATAType::RANG_sequence& DATAType::
RANG ()
{
  return this->RANG_;
}

void DATAType::
RANG (const RANG_sequence& s)
{
  this->RANG_ = s;
}

const DATAType::TYPE_sequence& DATAType::
TYPE () const
{
  return this->TYPE_;
}

DATAType::TYPE_sequence& DATAType::
TYPE ()
{
  return this->TYPE_;
}

void DATAType::
TYPE (const TYPE_sequence& s)
{
  this->TYPE_ = s;
}

const DATAType::INFO_sequence& DATAType::
INFO () const
{
  return this->INFO_;
}

DATAType::INFO_sequence& DATAType::
INFO ()
{
  return this->INFO_;
}

void DATAType::
INFO (const INFO_sequence& s)
{
  this->INFO_ = s;
}

const DATAType::Define_sequence& DATAType::
Define () const
{
  return this->Define_;
}

DATAType::Define_sequence& DATAType::
Define ()
{
  return this->Define_;
}

void DATAType::
Define (const Define_sequence& s)
{
  this->Define_ = s;
}

const DATAType::VALUE_RAW_sequence& DATAType::
VALUE_RAW () const
{
  return this->VALUE_RAW_;
}

DATAType::VALUE_RAW_sequence& DATAType::
VALUE_RAW ()
{
  return this->VALUE_RAW_;
}

void DATAType::
VALUE_RAW (const VALUE_RAW_sequence& s)
{
  this->VALUE_RAW_ = s;
}

const DATAType::VALUE_SYS_sequence& DATAType::
VALUE_SYS () const
{
  return this->VALUE_SYS_;
}

DATAType::VALUE_SYS_sequence& DATAType::
VALUE_SYS ()
{
  return this->VALUE_SYS_;
}

void DATAType::
VALUE_SYS (const VALUE_SYS_sequence& s)
{
  this->VALUE_SYS_ = s;
}


// DATA_SETType
// 

const DATA_SETType::DATA_FORMAT_optional& DATA_SETType::
DATA_FORMAT () const
{
  return this->DATA_FORMAT_;
}

DATA_SETType::DATA_FORMAT_optional& DATA_SETType::
DATA_FORMAT ()
{
  return this->DATA_FORMAT_;
}

void DATA_SETType::
DATA_FORMAT (const DATA_FORMAT_type& x)
{
  this->DATA_FORMAT_.set (x);
}

void DATA_SETType::
DATA_FORMAT (const DATA_FORMAT_optional& x)
{
  this->DATA_FORMAT_ = x;
}

void DATA_SETType::
DATA_FORMAT (::std::auto_ptr< DATA_FORMAT_type > x)
{
  this->DATA_FORMAT_.set (x);
}

const DATA_SETType::REF_PARSE_DATA_optional& DATA_SETType::
REF_PARSE_DATA () const
{
  return this->REF_PARSE_DATA_;
}

DATA_SETType::REF_PARSE_DATA_optional& DATA_SETType::
REF_PARSE_DATA ()
{
  return this->REF_PARSE_DATA_;
}

void DATA_SETType::
REF_PARSE_DATA (const REF_PARSE_DATA_type& x)
{
  this->REF_PARSE_DATA_.set (x);
}

void DATA_SETType::
REF_PARSE_DATA (const REF_PARSE_DATA_optional& x)
{
  this->REF_PARSE_DATA_ = x;
}

void DATA_SETType::
REF_PARSE_DATA (::std::auto_ptr< REF_PARSE_DATA_type > x)
{
  this->REF_PARSE_DATA_.set (x);
}

const DATA_SETType::RAW_type& DATA_SETType::
RAW () const
{
  return this->RAW_.get ();
}

DATA_SETType::RAW_type& DATA_SETType::
RAW ()
{
  return this->RAW_.get ();
}

void DATA_SETType::
RAW (const RAW_type& x)
{
  this->RAW_.set (x);
}

void DATA_SETType::
RAW (::std::auto_ptr< RAW_type > x)
{
  this->RAW_.set (x);
}

const DATA_SETType::DATA_sequence& DATA_SETType::
DATA () const
{
  return this->DATA_;
}

DATA_SETType::DATA_sequence& DATA_SETType::
DATA ()
{
  return this->DATA_;
}

void DATA_SETType::
DATA (const DATA_sequence& s)
{
  this->DATA_ = s;
}


// FRAMEType
// 

const FRAMEType::IDENTIFIANT_type& FRAMEType::
IDENTIFIANT () const
{
  return this->IDENTIFIANT_.get ();
}

FRAMEType::IDENTIFIANT_type& FRAMEType::
IDENTIFIANT ()
{
  return this->IDENTIFIANT_.get ();
}

void FRAMEType::
IDENTIFIANT (const IDENTIFIANT_type& x)
{
  this->IDENTIFIANT_.set (x);
}

void FRAMEType::
IDENTIFIANT (::std::auto_ptr< IDENTIFIANT_type > x)
{
  this->IDENTIFIANT_.set (x);
}

const FRAMEType::NOM_type& FRAMEType::
NOM () const
{
  return this->NOM_.get ();
}

FRAMEType::NOM_type& FRAMEType::
NOM ()
{
  return this->NOM_.get ();
}

void FRAMEType::
NOM (const NOM_type& x)
{
  this->NOM_.set (x);
}

void FRAMEType::
NOM (::std::auto_ptr< NOM_type > x)
{
  this->NOM_.set (x);
}

const FRAMEType::SOURCE_type& FRAMEType::
SOURCE () const
{
  return this->SOURCE_.get ();
}

FRAMEType::SOURCE_type& FRAMEType::
SOURCE ()
{
  return this->SOURCE_.get ();
}

void FRAMEType::
SOURCE (const SOURCE_type& x)
{
  this->SOURCE_.set (x);
}

void FRAMEType::
SOURCE (::std::auto_ptr< SOURCE_type > x)
{
  this->SOURCE_.set (x);
}

const FRAMEType::DESTINATION_type& FRAMEType::
DESTINATION () const
{
  return this->DESTINATION_.get ();
}

FRAMEType::DESTINATION_type& FRAMEType::
DESTINATION ()
{
  return this->DESTINATION_.get ();
}

void FRAMEType::
DESTINATION (const DESTINATION_type& x)
{
  this->DESTINATION_.set (x);
}

void FRAMEType::
DESTINATION (::std::auto_ptr< DESTINATION_type > x)
{
  this->DESTINATION_.set (x);
}

const FRAMEType::TIMESTAMP_type& FRAMEType::
TIMESTAMP () const
{
  return this->TIMESTAMP_.get ();
}

FRAMEType::TIMESTAMP_type& FRAMEType::
TIMESTAMP ()
{
  return this->TIMESTAMP_.get ();
}

void FRAMEType::
TIMESTAMP (const TIMESTAMP_type& x)
{
  this->TIMESTAMP_.set (x);
}

void FRAMEType::
TIMESTAMP (::std::auto_ptr< TIMESTAMP_type > x)
{
  this->TIMESTAMP_.set (x);
}

const FRAMEType::RAW_type& FRAMEType::
RAW () const
{
  return this->RAW_.get ();
}

FRAMEType::RAW_type& FRAMEType::
RAW ()
{
  return this->RAW_.get ();
}

void FRAMEType::
RAW (const RAW_type& x)
{
  this->RAW_.set (x);
}

void FRAMEType::
RAW (::std::auto_ptr< RAW_type > x)
{
  this->RAW_.set (x);
}

const FRAMEType::TYPE_type& FRAMEType::
TYPE () const
{
  return this->TYPE_.get ();
}

FRAMEType::TYPE_type& FRAMEType::
TYPE ()
{
  return this->TYPE_.get ();
}

void FRAMEType::
TYPE (const TYPE_type& x)
{
  this->TYPE_.set (x);
}

void FRAMEType::
TYPE (::std::auto_ptr< TYPE_type > x)
{
  this->TYPE_.set (x);
}

const FRAMEType::FRAME_NUMBER_type& FRAMEType::
FRAME_NUMBER () const
{
  return this->FRAME_NUMBER_.get ();
}

FRAMEType::FRAME_NUMBER_type& FRAMEType::
FRAME_NUMBER ()
{
  return this->FRAME_NUMBER_.get ();
}

void FRAMEType::
FRAME_NUMBER (const FRAME_NUMBER_type& x)
{
  this->FRAME_NUMBER_.set (x);
}

void FRAMEType::
FRAME_NUMBER (::std::auto_ptr< FRAME_NUMBER_type > x)
{
  this->FRAME_NUMBER_.set (x);
}

const FRAMEType::FRAME_PROTOCOL_type& FRAMEType::
FRAME_PROTOCOL () const
{
  return this->FRAME_PROTOCOL_.get ();
}

FRAMEType::FRAME_PROTOCOL_type& FRAMEType::
FRAME_PROTOCOL ()
{
  return this->FRAME_PROTOCOL_.get ();
}

void FRAMEType::
FRAME_PROTOCOL (const FRAME_PROTOCOL_type& x)
{
  this->FRAME_PROTOCOL_.set (x);
}

void FRAMEType::
FRAME_PROTOCOL (::std::auto_ptr< FRAME_PROTOCOL_type > x)
{
  this->FRAME_PROTOCOL_.set (x);
}

const FRAMEType::IP_PROTOCOL_type& FRAMEType::
IP_PROTOCOL () const
{
  return this->IP_PROTOCOL_.get ();
}

FRAMEType::IP_PROTOCOL_type& FRAMEType::
IP_PROTOCOL ()
{
  return this->IP_PROTOCOL_.get ();
}

void FRAMEType::
IP_PROTOCOL (const IP_PROTOCOL_type& x)
{
  this->IP_PROTOCOL_.set (x);
}

void FRAMEType::
IP_PROTOCOL (::std::auto_ptr< IP_PROTOCOL_type > x)
{
  this->IP_PROTOCOL_.set (x);
}

const FRAMEType::TRANSMISSION_PROTOCOL_type& FRAMEType::
TRANSMISSION_PROTOCOL () const
{
  return this->TRANSMISSION_PROTOCOL_.get ();
}

FRAMEType::TRANSMISSION_PROTOCOL_type& FRAMEType::
TRANSMISSION_PROTOCOL ()
{
  return this->TRANSMISSION_PROTOCOL_.get ();
}

void FRAMEType::
TRANSMISSION_PROTOCOL (const TRANSMISSION_PROTOCOL_type& x)
{
  this->TRANSMISSION_PROTOCOL_.set (x);
}

void FRAMEType::
TRANSMISSION_PROTOCOL (::std::auto_ptr< TRANSMISSION_PROTOCOL_type > x)
{
  this->TRANSMISSION_PROTOCOL_.set (x);
}

const FRAMEType::DATA_SET_type& FRAMEType::
DATA_SET () const
{
  return this->DATA_SET_.get ();
}

FRAMEType::DATA_SET_type& FRAMEType::
DATA_SET ()
{
  return this->DATA_SET_.get ();
}

void FRAMEType::
DATA_SET (const DATA_SET_type& x)
{
  this->DATA_SET_.set (x);
}

void FRAMEType::
DATA_SET (::std::auto_ptr< DATA_SET_type > x)
{
  this->DATA_SET_.set (x);
}


// OUTPUTType
// 

const OUTPUTType::TEST_REF_type& OUTPUTType::
TEST_REF () const
{
  return this->TEST_REF_.get ();
}

OUTPUTType::TEST_REF_type& OUTPUTType::
TEST_REF ()
{
  return this->TEST_REF_.get ();
}

void OUTPUTType::
TEST_REF (const TEST_REF_type& x)
{
  this->TEST_REF_.set (x);
}

void OUTPUTType::
TEST_REF (::std::auto_ptr< TEST_REF_type > x)
{
  this->TEST_REF_.set (x);
}

const OUTPUTType::TOOL_CFG_type& OUTPUTType::
TOOL_CFG () const
{
  return this->TOOL_CFG_.get ();
}

OUTPUTType::TOOL_CFG_type& OUTPUTType::
TOOL_CFG ()
{
  return this->TOOL_CFG_.get ();
}

void OUTPUTType::
TOOL_CFG (const TOOL_CFG_type& x)
{
  this->TOOL_CFG_.set (x);
}

void OUTPUTType::
TOOL_CFG (::std::auto_ptr< TOOL_CFG_type > x)
{
  this->TOOL_CFG_.set (x);
}

const OUTPUTType::FRAME_sequence& OUTPUTType::
FRAME () const
{
  return this->FRAME_;
}

OUTPUTType::FRAME_sequence& OUTPUTType::
FRAME ()
{
  return this->FRAME_;
}

void OUTPUTType::
FRAME (const FRAME_sequence& s)
{
  this->FRAME_ = s;
}


// BDD_OUTPUT_DATAType
// 

const BDD_OUTPUT_DATAType::OUTPUT_type& BDD_OUTPUT_DATAType::
OUTPUT () const
{
  return this->OUTPUT_.get ();
}

BDD_OUTPUT_DATAType::OUTPUT_type& BDD_OUTPUT_DATAType::
OUTPUT ()
{
  return this->OUTPUT_.get ();
}

void BDD_OUTPUT_DATAType::
OUTPUT (const OUTPUT_type& x)
{
  this->OUTPUT_.set (x);
}

void BDD_OUTPUT_DATAType::
OUTPUT (::std::auto_ptr< OUTPUT_type > x)
{
  this->OUTPUT_.set (x);
}


// DATATypeTYPE
// 

DATATypeTYPE::
DATATypeTYPE (value v)
: ::xml_schema::string (_xsd_DATATypeTYPE_literals_[v])
{
}

DATATypeTYPE::
DATATypeTYPE (const char* v)
: ::xml_schema::string (v)
{
}

DATATypeTYPE::
DATATypeTYPE (const ::std::string& v)
: ::xml_schema::string (v)
{
}

DATATypeTYPE::
DATATypeTYPE (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

DATATypeTYPE::
DATATypeTYPE (const DATATypeTYPE& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

DATATypeTYPE& DATATypeTYPE::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_DATATypeTYPE_literals_[v]);

  return *this;
}


// FRAMETypeIDENTIFIANT
// 

FRAMETypeIDENTIFIANT::
FRAMETypeIDENTIFIANT (value v)
: ::xml_schema::string (_xsd_FRAMETypeIDENTIFIANT_literals_[v])
{
}

FRAMETypeIDENTIFIANT::
FRAMETypeIDENTIFIANT (const char* v)
: ::xml_schema::string (v)
{
}

FRAMETypeIDENTIFIANT::
FRAMETypeIDENTIFIANT (const ::std::string& v)
: ::xml_schema::string (v)
{
}

FRAMETypeIDENTIFIANT::
FRAMETypeIDENTIFIANT (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

FRAMETypeIDENTIFIANT::
FRAMETypeIDENTIFIANT (const FRAMETypeIDENTIFIANT& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

FRAMETypeIDENTIFIANT& FRAMETypeIDENTIFIANT::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_FRAMETypeIDENTIFIANT_literals_[v]);

  return *this;
}


// FRAMETypeNOM
// 

FRAMETypeNOM::
FRAMETypeNOM (value v)
: ::xml_schema::string (_xsd_FRAMETypeNOM_literals_[v])
{
}

FRAMETypeNOM::
FRAMETypeNOM (const char* v)
: ::xml_schema::string (v)
{
}

FRAMETypeNOM::
FRAMETypeNOM (const ::std::string& v)
: ::xml_schema::string (v)
{
}

FRAMETypeNOM::
FRAMETypeNOM (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

FRAMETypeNOM::
FRAMETypeNOM (const FRAMETypeNOM& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

FRAMETypeNOM& FRAMETypeNOM::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_FRAMETypeNOM_literals_[v]);

  return *this;
}


// FRAMETypeSOURCE
// 

FRAMETypeSOURCE::
FRAMETypeSOURCE (value v)
: ::xml_schema::string (_xsd_FRAMETypeSOURCE_literals_[v])
{
}

FRAMETypeSOURCE::
FRAMETypeSOURCE (const char* v)
: ::xml_schema::string (v)
{
}

FRAMETypeSOURCE::
FRAMETypeSOURCE (const ::std::string& v)
: ::xml_schema::string (v)
{
}

FRAMETypeSOURCE::
FRAMETypeSOURCE (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

FRAMETypeSOURCE::
FRAMETypeSOURCE (const FRAMETypeSOURCE& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

FRAMETypeSOURCE& FRAMETypeSOURCE::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_FRAMETypeSOURCE_literals_[v]);

  return *this;
}


// FRAMETypeDESTINATION
// 

FRAMETypeDESTINATION::
FRAMETypeDESTINATION (value v)
: ::xml_schema::string (_xsd_FRAMETypeDESTINATION_literals_[v])
{
}

FRAMETypeDESTINATION::
FRAMETypeDESTINATION (const char* v)
: ::xml_schema::string (v)
{
}

FRAMETypeDESTINATION::
FRAMETypeDESTINATION (const ::std::string& v)
: ::xml_schema::string (v)
{
}

FRAMETypeDESTINATION::
FRAMETypeDESTINATION (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

FRAMETypeDESTINATION::
FRAMETypeDESTINATION (const FRAMETypeDESTINATION& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

FRAMETypeDESTINATION& FRAMETypeDESTINATION::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_FRAMETypeDESTINATION_literals_[v]);

  return *this;
}


// FRAMETypeTYPE
// 

FRAMETypeTYPE::
FRAMETypeTYPE (value v)
: ::xml_schema::string (_xsd_FRAMETypeTYPE_literals_[v])
{
}

FRAMETypeTYPE::
FRAMETypeTYPE (const char* v)
: ::xml_schema::string (v)
{
}

FRAMETypeTYPE::
FRAMETypeTYPE (const ::std::string& v)
: ::xml_schema::string (v)
{
}

FRAMETypeTYPE::
FRAMETypeTYPE (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

FRAMETypeTYPE::
FRAMETypeTYPE (const FRAMETypeTYPE& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

FRAMETypeTYPE& FRAMETypeTYPE::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_FRAMETypeTYPE_literals_[v]);

  return *this;
}


// FRAMETypeFRAME_NUMBER
// 

FRAMETypeFRAME_NUMBER::
FRAMETypeFRAME_NUMBER (value v)
: ::xml_schema::string (_xsd_FRAMETypeFRAME_NUMBER_literals_[v])
{
}

FRAMETypeFRAME_NUMBER::
FRAMETypeFRAME_NUMBER (const char* v)
: ::xml_schema::string (v)
{
}

FRAMETypeFRAME_NUMBER::
FRAMETypeFRAME_NUMBER (const ::std::string& v)
: ::xml_schema::string (v)
{
}

FRAMETypeFRAME_NUMBER::
FRAMETypeFRAME_NUMBER (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

FRAMETypeFRAME_NUMBER::
FRAMETypeFRAME_NUMBER (const FRAMETypeFRAME_NUMBER& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

FRAMETypeFRAME_NUMBER& FRAMETypeFRAME_NUMBER::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_FRAMETypeFRAME_NUMBER_literals_[v]);

  return *this;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// EXIGENCESType
//

EXIGENCESType::
EXIGENCESType ()
: ::xml_schema::type (),
  ID_EXI_ (this)
{
}

EXIGENCESType::
EXIGENCESType (const EXIGENCESType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ID_EXI_ (x.ID_EXI_, f, this)
{
}

EXIGENCESType::
EXIGENCESType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ID_EXI_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void EXIGENCESType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ID_EXI
    //
    if (n.name () == "ID_EXI" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ID_EXI_type > r (
        ID_EXI_traits::create (i, f, this));

      this->ID_EXI_.push_back (r);
      continue;
    }

    break;
  }
}

EXIGENCESType* EXIGENCESType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EXIGENCESType (*this, f, c);
}

EXIGENCESType& EXIGENCESType::
operator= (const EXIGENCESType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ID_EXI_ = x.ID_EXI_;
  }

  return *this;
}

EXIGENCESType::
~EXIGENCESType ()
{
}

// LOGICIELType
//

LOGICIELType::
LOGICIELType (const SSG_type& SSG,
              const SST_type& SST)
: ::xml_schema::type (),
  SSG_ (SSG, this),
  SST_ (SST, this)
{
}

LOGICIELType::
LOGICIELType (const LOGICIELType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  SSG_ (x.SSG_, f, this),
  SST_ (x.SST_, f, this)
{
}

LOGICIELType::
LOGICIELType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  SSG_ (this),
  SST_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void LOGICIELType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // SSG
    //
    if (n.name () == "SSG" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SSG_type > r (
        SSG_traits::create (i, f, this));

      if (!SSG_.present ())
      {
        this->SSG_.set (r);
        continue;
      }
    }

    // SST
    //
    if (n.name () == "SST" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SST_type > r (
        SST_traits::create (i, f, this));

      if (!SST_.present ())
      {
        this->SST_.set (r);
        continue;
      }
    }

    break;
  }

  if (!SSG_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SSG",
      "");
  }

  if (!SST_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SST",
      "");
  }
}

LOGICIELType* LOGICIELType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LOGICIELType (*this, f, c);
}

LOGICIELType& LOGICIELType::
operator= (const LOGICIELType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->SSG_ = x.SSG_;
    this->SST_ = x.SST_;
  }

  return *this;
}

LOGICIELType::
~LOGICIELType ()
{
}

// MATERIELType
//

MATERIELType::
MATERIELType (const SSG_type& SSG,
              const SST_type& SST)
: ::xml_schema::type (),
  SSG_ (SSG, this),
  SST_ (SST, this)
{
}

MATERIELType::
MATERIELType (const MATERIELType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  SSG_ (x.SSG_, f, this),
  SST_ (x.SST_, f, this)
{
}

MATERIELType::
MATERIELType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  SSG_ (this),
  SST_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MATERIELType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // SSG
    //
    if (n.name () == "SSG" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SSG_type > r (
        SSG_traits::create (i, f, this));

      if (!SSG_.present ())
      {
        this->SSG_.set (r);
        continue;
      }
    }

    // SST
    //
    if (n.name () == "SST" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SST_type > r (
        SST_traits::create (i, f, this));

      if (!SST_.present ())
      {
        this->SST_.set (r);
        continue;
      }
    }

    break;
  }

  if (!SSG_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SSG",
      "");
  }

  if (!SST_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SST",
      "");
  }
}

MATERIELType* MATERIELType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MATERIELType (*this, f, c);
}

MATERIELType& MATERIELType::
operator= (const MATERIELType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->SSG_ = x.SSG_;
    this->SST_ = x.SST_;
  }

  return *this;
}

MATERIELType::
~MATERIELType ()
{
}

// CONFIGURATIONType
//

CONFIGURATIONType::
CONFIGURATIONType (const LOGICIEL_type& LOGICIEL,
                   const MATERIEL_type& MATERIEL)
: ::xml_schema::type (),
  LOGICIEL_ (LOGICIEL, this),
  MATERIEL_ (MATERIEL, this)
{
}

CONFIGURATIONType::
CONFIGURATIONType (::std::auto_ptr< LOGICIEL_type > LOGICIEL,
                   ::std::auto_ptr< MATERIEL_type > MATERIEL)
: ::xml_schema::type (),
  LOGICIEL_ (LOGICIEL, this),
  MATERIEL_ (MATERIEL, this)
{
}

CONFIGURATIONType::
CONFIGURATIONType (const CONFIGURATIONType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LOGICIEL_ (x.LOGICIEL_, f, this),
  MATERIEL_ (x.MATERIEL_, f, this)
{
}

CONFIGURATIONType::
CONFIGURATIONType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LOGICIEL_ (this),
  MATERIEL_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CONFIGURATIONType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LOGICIEL
    //
    if (n.name () == "LOGICIEL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LOGICIEL_type > r (
        LOGICIEL_traits::create (i, f, this));

      if (!LOGICIEL_.present ())
      {
        this->LOGICIEL_.set (r);
        continue;
      }
    }

    // MATERIEL
    //
    if (n.name () == "MATERIEL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MATERIEL_type > r (
        MATERIEL_traits::create (i, f, this));

      if (!MATERIEL_.present ())
      {
        this->MATERIEL_.set (r);
        continue;
      }
    }

    break;
  }

  if (!LOGICIEL_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "LOGICIEL",
      "");
  }

  if (!MATERIEL_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "MATERIEL",
      "");
  }
}

CONFIGURATIONType* CONFIGURATIONType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CONFIGURATIONType (*this, f, c);
}

CONFIGURATIONType& CONFIGURATIONType::
operator= (const CONFIGURATIONType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->LOGICIEL_ = x.LOGICIEL_;
    this->MATERIEL_ = x.MATERIEL_;
  }

  return *this;
}

CONFIGURATIONType::
~CONFIGURATIONType ()
{
}

// TEST_REFType
//

TEST_REFType::
TEST_REFType (const TEST_ID_type& TEST_ID,
              const ORIGINE_type& ORIGINE,
              const TITRE_type& TITRE,
              const REFERENCE_PROCEDURE_type& REFERENCE_PROCEDURE,
              const VERSION_PROCEDURE_type& VERSION_PROCEDURE,
              const SECTION_PROCEDURE_type& SECTION_PROCEDURE,
              const EXIGENCES_type& EXIGENCES,
              const CONFIGURATION_type& CONFIGURATION,
              const DATE_type& DATE,
              const HEURE_type& HEURE,
              const LIEU_type& LIEU,
              const OPERATEUR_type& OPERATEUR,
              const COMMENT_type& COMMENT,
              const VALIDITE_type& VALIDITE,
              const SAUVEGARDE_type& SAUVEGARDE)
: ::xml_schema::type (),
  TEST_ID_ (TEST_ID, this),
  ORIGINE_ (ORIGINE, this),
  TITRE_ (TITRE, this),
  REFERENCE_PROCEDURE_ (REFERENCE_PROCEDURE, this),
  VERSION_PROCEDURE_ (VERSION_PROCEDURE, this),
  SECTION_PROCEDURE_ (SECTION_PROCEDURE, this),
  EXIGENCES_ (EXIGENCES, this),
  CONFIGURATION_ (CONFIGURATION, this),
  DATE_ (DATE, this),
  HEURE_ (HEURE, this),
  LIEU_ (LIEU, this),
  OPERATEUR_ (OPERATEUR, this),
  COMMENT_ (COMMENT, this),
  VALIDITE_ (VALIDITE, this),
  SAUVEGARDE_ (SAUVEGARDE, this)
{
}

TEST_REFType::
TEST_REFType (const TEST_ID_type& TEST_ID,
              const ORIGINE_type& ORIGINE,
              const TITRE_type& TITRE,
              const REFERENCE_PROCEDURE_type& REFERENCE_PROCEDURE,
              const VERSION_PROCEDURE_type& VERSION_PROCEDURE,
              const SECTION_PROCEDURE_type& SECTION_PROCEDURE,
              ::std::auto_ptr< EXIGENCES_type > EXIGENCES,
              ::std::auto_ptr< CONFIGURATION_type > CONFIGURATION,
              const DATE_type& DATE,
              const HEURE_type& HEURE,
              const LIEU_type& LIEU,
              const OPERATEUR_type& OPERATEUR,
              const COMMENT_type& COMMENT,
              const VALIDITE_type& VALIDITE,
              const SAUVEGARDE_type& SAUVEGARDE)
: ::xml_schema::type (),
  TEST_ID_ (TEST_ID, this),
  ORIGINE_ (ORIGINE, this),
  TITRE_ (TITRE, this),
  REFERENCE_PROCEDURE_ (REFERENCE_PROCEDURE, this),
  VERSION_PROCEDURE_ (VERSION_PROCEDURE, this),
  SECTION_PROCEDURE_ (SECTION_PROCEDURE, this),
  EXIGENCES_ (EXIGENCES, this),
  CONFIGURATION_ (CONFIGURATION, this),
  DATE_ (DATE, this),
  HEURE_ (HEURE, this),
  LIEU_ (LIEU, this),
  OPERATEUR_ (OPERATEUR, this),
  COMMENT_ (COMMENT, this),
  VALIDITE_ (VALIDITE, this),
  SAUVEGARDE_ (SAUVEGARDE, this)
{
}

TEST_REFType::
TEST_REFType (const TEST_REFType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  TEST_ID_ (x.TEST_ID_, f, this),
  ORIGINE_ (x.ORIGINE_, f, this),
  TITRE_ (x.TITRE_, f, this),
  REFERENCE_PROCEDURE_ (x.REFERENCE_PROCEDURE_, f, this),
  VERSION_PROCEDURE_ (x.VERSION_PROCEDURE_, f, this),
  SECTION_PROCEDURE_ (x.SECTION_PROCEDURE_, f, this),
  EXIGENCES_ (x.EXIGENCES_, f, this),
  CONFIGURATION_ (x.CONFIGURATION_, f, this),
  DATE_ (x.DATE_, f, this),
  HEURE_ (x.HEURE_, f, this),
  LIEU_ (x.LIEU_, f, this),
  OPERATEUR_ (x.OPERATEUR_, f, this),
  COMMENT_ (x.COMMENT_, f, this),
  VALIDITE_ (x.VALIDITE_, f, this),
  SAUVEGARDE_ (x.SAUVEGARDE_, f, this)
{
}

TEST_REFType::
TEST_REFType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  TEST_ID_ (this),
  ORIGINE_ (this),
  TITRE_ (this),
  REFERENCE_PROCEDURE_ (this),
  VERSION_PROCEDURE_ (this),
  SECTION_PROCEDURE_ (this),
  EXIGENCES_ (this),
  CONFIGURATION_ (this),
  DATE_ (this),
  HEURE_ (this),
  LIEU_ (this),
  OPERATEUR_ (this),
  COMMENT_ (this),
  VALIDITE_ (this),
  SAUVEGARDE_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TEST_REFType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TEST_ID
    //
    if (n.name () == "TEST_ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TEST_ID_type > r (
        TEST_ID_traits::create (i, f, this));

      if (!TEST_ID_.present ())
      {
        this->TEST_ID_.set (r);
        continue;
      }
    }

    // ORIGINE
    //
    if (n.name () == "ORIGINE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ORIGINE_type > r (
        ORIGINE_traits::create (i, f, this));

      if (!ORIGINE_.present ())
      {
        this->ORIGINE_.set (r);
        continue;
      }
    }

    // TITRE
    //
    if (n.name () == "TITRE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TITRE_type > r (
        TITRE_traits::create (i, f, this));

      if (!TITRE_.present ())
      {
        this->TITRE_.set (r);
        continue;
      }
    }

    // REFERENCE_PROCEDURE
    //
    if (n.name () == "REFERENCE_PROCEDURE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< REFERENCE_PROCEDURE_type > r (
        REFERENCE_PROCEDURE_traits::create (i, f, this));

      if (!REFERENCE_PROCEDURE_.present ())
      {
        this->REFERENCE_PROCEDURE_.set (r);
        continue;
      }
    }

    // VERSION_PROCEDURE
    //
    if (n.name () == "VERSION_PROCEDURE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< VERSION_PROCEDURE_type > r (
        VERSION_PROCEDURE_traits::create (i, f, this));

      if (!VERSION_PROCEDURE_.present ())
      {
        this->VERSION_PROCEDURE_.set (r);
        continue;
      }
    }

    // SECTION_PROCEDURE
    //
    if (n.name () == "SECTION_PROCEDURE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SECTION_PROCEDURE_type > r (
        SECTION_PROCEDURE_traits::create (i, f, this));

      if (!SECTION_PROCEDURE_.present ())
      {
        this->SECTION_PROCEDURE_.set (r);
        continue;
      }
    }

    // EXIGENCES
    //
    if (n.name () == "EXIGENCES" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EXIGENCES_type > r (
        EXIGENCES_traits::create (i, f, this));

      if (!EXIGENCES_.present ())
      {
        this->EXIGENCES_.set (r);
        continue;
      }
    }

    // CONFIGURATION
    //
    if (n.name () == "CONFIGURATION" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CONFIGURATION_type > r (
        CONFIGURATION_traits::create (i, f, this));

      if (!CONFIGURATION_.present ())
      {
        this->CONFIGURATION_.set (r);
        continue;
      }
    }

    // DATE
    //
    if (n.name () == "DATE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DATE_type > r (
        DATE_traits::create (i, f, this));

      if (!DATE_.present ())
      {
        this->DATE_.set (r);
        continue;
      }
    }

    // HEURE
    //
    if (n.name () == "HEURE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< HEURE_type > r (
        HEURE_traits::create (i, f, this));

      if (!HEURE_.present ())
      {
        this->HEURE_.set (r);
        continue;
      }
    }

    // LIEU
    //
    if (n.name () == "LIEU" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LIEU_type > r (
        LIEU_traits::create (i, f, this));

      if (!LIEU_.present ())
      {
        this->LIEU_.set (r);
        continue;
      }
    }

    // OPERATEUR
    //
    if (n.name () == "OPERATEUR" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< OPERATEUR_type > r (
        OPERATEUR_traits::create (i, f, this));

      if (!OPERATEUR_.present ())
      {
        this->OPERATEUR_.set (r);
        continue;
      }
    }

    // COMMENT
    //
    if (n.name () == "COMMENT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< COMMENT_type > r (
        COMMENT_traits::create (i, f, this));

      if (!COMMENT_.present ())
      {
        this->COMMENT_.set (r);
        continue;
      }
    }

    // VALIDITE
    //
    if (n.name () == "VALIDITE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< VALIDITE_type > r (
        VALIDITE_traits::create (i, f, this));

      if (!VALIDITE_.present ())
      {
        this->VALIDITE_.set (r);
        continue;
      }
    }

    // SAUVEGARDE
    //
    if (n.name () == "SAUVEGARDE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SAUVEGARDE_type > r (
        SAUVEGARDE_traits::create (i, f, this));

      if (!SAUVEGARDE_.present ())
      {
        this->SAUVEGARDE_.set (r);
        continue;
      }
    }

    break;
  }

  if (!TEST_ID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TEST_ID",
      "");
  }

  if (!ORIGINE_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ORIGINE",
      "");
  }

  if (!TITRE_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TITRE",
      "");
  }

  if (!REFERENCE_PROCEDURE_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "REFERENCE_PROCEDURE",
      "");
  }

  if (!VERSION_PROCEDURE_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "VERSION_PROCEDURE",
      "");
  }

  if (!SECTION_PROCEDURE_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SECTION_PROCEDURE",
      "");
  }

  if (!EXIGENCES_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "EXIGENCES",
      "");
  }

  if (!CONFIGURATION_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CONFIGURATION",
      "");
  }

  if (!DATE_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DATE",
      "");
  }

  if (!HEURE_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "HEURE",
      "");
  }

  if (!LIEU_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "LIEU",
      "");
  }

  if (!OPERATEUR_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "OPERATEUR",
      "");
  }

  if (!COMMENT_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "COMMENT",
      "");
  }

  if (!VALIDITE_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "VALIDITE",
      "");
  }

  if (!SAUVEGARDE_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SAUVEGARDE",
      "");
  }
}

TEST_REFType* TEST_REFType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TEST_REFType (*this, f, c);
}

TEST_REFType& TEST_REFType::
operator= (const TEST_REFType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->TEST_ID_ = x.TEST_ID_;
    this->ORIGINE_ = x.ORIGINE_;
    this->TITRE_ = x.TITRE_;
    this->REFERENCE_PROCEDURE_ = x.REFERENCE_PROCEDURE_;
    this->VERSION_PROCEDURE_ = x.VERSION_PROCEDURE_;
    this->SECTION_PROCEDURE_ = x.SECTION_PROCEDURE_;
    this->EXIGENCES_ = x.EXIGENCES_;
    this->CONFIGURATION_ = x.CONFIGURATION_;
    this->DATE_ = x.DATE_;
    this->HEURE_ = x.HEURE_;
    this->LIEU_ = x.LIEU_;
    this->OPERATEUR_ = x.OPERATEUR_;
    this->COMMENT_ = x.COMMENT_;
    this->VALIDITE_ = x.VALIDITE_;
    this->SAUVEGARDE_ = x.SAUVEGARDE_;
  }

  return *this;
}

TEST_REFType::
~TEST_REFType ()
{
}

// FILESType
//

FILESType::
FILESType (const CFG_IP_type& CFG_IP,
           const CFG_FLUX_type& CFG_FLUX,
           const CFG_DATA_type& CFG_DATA,
           const CFG_DATA_VAL_type& CFG_DATA_VAL,
           const CFG_TEST_type& CFG_TEST)
: ::xml_schema::type (),
  CFG_IP_ (CFG_IP, this),
  CFG_FLUX_ (CFG_FLUX, this),
  CFG_DATA_ (CFG_DATA, this),
  CFG_DATA_VAL_ (CFG_DATA_VAL, this),
  CFG_TEST_ (CFG_TEST, this)
{
}

FILESType::
FILESType (const FILESType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  CFG_IP_ (x.CFG_IP_, f, this),
  CFG_FLUX_ (x.CFG_FLUX_, f, this),
  CFG_DATA_ (x.CFG_DATA_, f, this),
  CFG_DATA_VAL_ (x.CFG_DATA_VAL_, f, this),
  CFG_TEST_ (x.CFG_TEST_, f, this)
{
}

FILESType::
FILESType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  CFG_IP_ (this),
  CFG_FLUX_ (this),
  CFG_DATA_ (this),
  CFG_DATA_VAL_ (this),
  CFG_TEST_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void FILESType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CFG_IP
    //
    if (n.name () == "CFG_IP" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CFG_IP_type > r (
        CFG_IP_traits::create (i, f, this));

      if (!CFG_IP_.present ())
      {
        this->CFG_IP_.set (r);
        continue;
      }
    }

    // CFG_FLUX
    //
    if (n.name () == "CFG_FLUX" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CFG_FLUX_type > r (
        CFG_FLUX_traits::create (i, f, this));

      if (!CFG_FLUX_.present ())
      {
        this->CFG_FLUX_.set (r);
        continue;
      }
    }

    // CFG_DATA
    //
    if (n.name () == "CFG_DATA" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CFG_DATA_type > r (
        CFG_DATA_traits::create (i, f, this));

      if (!CFG_DATA_.present ())
      {
        this->CFG_DATA_.set (r);
        continue;
      }
    }

    // CFG_DATA_VAL
    //
    if (n.name () == "CFG_DATA_VAL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CFG_DATA_VAL_type > r (
        CFG_DATA_VAL_traits::create (i, f, this));

      if (!CFG_DATA_VAL_.present ())
      {
        this->CFG_DATA_VAL_.set (r);
        continue;
      }
    }

    // CFG_TEST
    //
    if (n.name () == "CFG_TEST" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CFG_TEST_type > r (
        CFG_TEST_traits::create (i, f, this));

      if (!CFG_TEST_.present ())
      {
        this->CFG_TEST_.set (r);
        continue;
      }
    }

    break;
  }

  if (!CFG_IP_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CFG_IP",
      "");
  }

  if (!CFG_FLUX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CFG_FLUX",
      "");
  }

  if (!CFG_DATA_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CFG_DATA",
      "");
  }

  if (!CFG_DATA_VAL_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CFG_DATA_VAL",
      "");
  }

  if (!CFG_TEST_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CFG_TEST",
      "");
  }
}

FILESType* FILESType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FILESType (*this, f, c);
}

FILESType& FILESType::
operator= (const FILESType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->CFG_IP_ = x.CFG_IP_;
    this->CFG_FLUX_ = x.CFG_FLUX_;
    this->CFG_DATA_ = x.CFG_DATA_;
    this->CFG_DATA_VAL_ = x.CFG_DATA_VAL_;
    this->CFG_TEST_ = x.CFG_TEST_;
  }

  return *this;
}

FILESType::
~FILESType ()
{
}

// TOOL_CFGType
//

TOOL_CFGType::
TOOL_CFGType (const IDENT_type& IDENT,
              const VERSION_type& VERSION,
              const FILES_type& FILES,
              const DATE_type& DATE,
              const HEURE_type& HEURE)
: ::xml_schema::type (),
  IDENT_ (IDENT, this),
  VERSION_ (VERSION, this),
  FILES_ (FILES, this),
  DATE_ (DATE, this),
  HEURE_ (HEURE, this)
{
}

TOOL_CFGType::
TOOL_CFGType (const IDENT_type& IDENT,
              const VERSION_type& VERSION,
              ::std::auto_ptr< FILES_type > FILES,
              const DATE_type& DATE,
              const HEURE_type& HEURE)
: ::xml_schema::type (),
  IDENT_ (IDENT, this),
  VERSION_ (VERSION, this),
  FILES_ (FILES, this),
  DATE_ (DATE, this),
  HEURE_ (HEURE, this)
{
}

TOOL_CFGType::
TOOL_CFGType (const TOOL_CFGType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  IDENT_ (x.IDENT_, f, this),
  VERSION_ (x.VERSION_, f, this),
  FILES_ (x.FILES_, f, this),
  DATE_ (x.DATE_, f, this),
  HEURE_ (x.HEURE_, f, this)
{
}

TOOL_CFGType::
TOOL_CFGType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  IDENT_ (this),
  VERSION_ (this),
  FILES_ (this),
  DATE_ (this),
  HEURE_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TOOL_CFGType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // IDENT
    //
    if (n.name () == "IDENT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IDENT_type > r (
        IDENT_traits::create (i, f, this));

      if (!IDENT_.present ())
      {
        this->IDENT_.set (r);
        continue;
      }
    }

    // VERSION
    //
    if (n.name () == "VERSION" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< VERSION_type > r (
        VERSION_traits::create (i, f, this));

      if (!VERSION_.present ())
      {
        this->VERSION_.set (r);
        continue;
      }
    }

    // FILES
    //
    if (n.name () == "FILES" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FILES_type > r (
        FILES_traits::create (i, f, this));

      if (!FILES_.present ())
      {
        this->FILES_.set (r);
        continue;
      }
    }

    // DATE
    //
    if (n.name () == "DATE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DATE_type > r (
        DATE_traits::create (i, f, this));

      if (!DATE_.present ())
      {
        this->DATE_.set (r);
        continue;
      }
    }

    // HEURE
    //
    if (n.name () == "HEURE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< HEURE_type > r (
        HEURE_traits::create (i, f, this));

      if (!HEURE_.present ())
      {
        this->HEURE_.set (r);
        continue;
      }
    }

    break;
  }

  if (!IDENT_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "IDENT",
      "");
  }

  if (!VERSION_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "VERSION",
      "");
  }

  if (!FILES_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "FILES",
      "");
  }

  if (!DATE_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DATE",
      "");
  }

  if (!HEURE_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "HEURE",
      "");
  }
}

TOOL_CFGType* TOOL_CFGType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TOOL_CFGType (*this, f, c);
}

TOOL_CFGType& TOOL_CFGType::
operator= (const TOOL_CFGType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->IDENT_ = x.IDENT_;
    this->VERSION_ = x.VERSION_;
    this->FILES_ = x.FILES_;
    this->DATE_ = x.DATE_;
    this->HEURE_ = x.HEURE_;
  }

  return *this;
}

TOOL_CFGType::
~TOOL_CFGType ()
{
}

// IP_PROTOCOLType
//

IP_PROTOCOLType::
IP_PROTOCOLType (const FLAGS_type& FLAGS,
                 const Header_CHECKSUM_type& Header_CHECKSUM)
: ::xml_schema::type (),
  FLAGS_ (FLAGS, this),
  Header_CHECKSUM_ (Header_CHECKSUM, this)
{
}

IP_PROTOCOLType::
IP_PROTOCOLType (const IP_PROTOCOLType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  FLAGS_ (x.FLAGS_, f, this),
  Header_CHECKSUM_ (x.Header_CHECKSUM_, f, this)
{
}

IP_PROTOCOLType::
IP_PROTOCOLType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  FLAGS_ (this),
  Header_CHECKSUM_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void IP_PROTOCOLType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // FLAGS
    //
    if (n.name () == "FLAGS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FLAGS_type > r (
        FLAGS_traits::create (i, f, this));

      if (!FLAGS_.present ())
      {
        this->FLAGS_.set (r);
        continue;
      }
    }

    // Header_CHECKSUM
    //
    if (n.name () == "Header_CHECKSUM" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Header_CHECKSUM_type > r (
        Header_CHECKSUM_traits::create (i, f, this));

      if (!Header_CHECKSUM_.present ())
      {
        this->Header_CHECKSUM_.set (r);
        continue;
      }
    }

    break;
  }

  if (!FLAGS_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "FLAGS",
      "");
  }

  if (!Header_CHECKSUM_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Header_CHECKSUM",
      "");
  }
}

IP_PROTOCOLType* IP_PROTOCOLType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IP_PROTOCOLType (*this, f, c);
}

IP_PROTOCOLType& IP_PROTOCOLType::
operator= (const IP_PROTOCOLType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->FLAGS_ = x.FLAGS_;
    this->Header_CHECKSUM_ = x.Header_CHECKSUM_;
  }

  return *this;
}

IP_PROTOCOLType::
~IP_PROTOCOLType ()
{
}

// TRANSMISSION_PROTOCOLType
//

TRANSMISSION_PROTOCOLType::
TRANSMISSION_PROTOCOLType (const SEQ_NUMBER_type& SEQ_NUMBER,
                           const ACK_RTT_type& ACK_RTT,
                           const FLAGS_type& FLAGS)
: ::xml_schema::type (),
  SEQ_NUMBER_ (SEQ_NUMBER, this),
  ACK_RTT_ (ACK_RTT, this),
  FLAGS_ (FLAGS, this)
{
}

TRANSMISSION_PROTOCOLType::
TRANSMISSION_PROTOCOLType (const TRANSMISSION_PROTOCOLType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  SEQ_NUMBER_ (x.SEQ_NUMBER_, f, this),
  ACK_RTT_ (x.ACK_RTT_, f, this),
  FLAGS_ (x.FLAGS_, f, this)
{
}

TRANSMISSION_PROTOCOLType::
TRANSMISSION_PROTOCOLType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  SEQ_NUMBER_ (this),
  ACK_RTT_ (this),
  FLAGS_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TRANSMISSION_PROTOCOLType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // SEQ_NUMBER
    //
    if (n.name () == "SEQ_NUMBER" && n.namespace_ ().empty ())
    {
      if (!SEQ_NUMBER_.present ())
      {
        this->SEQ_NUMBER_.set (SEQ_NUMBER_traits::create (i, f, this));
        continue;
      }
    }

    // ACK_RTT
    //
    if (n.name () == "ACK_RTT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ACK_RTT_type > r (
        ACK_RTT_traits::create (i, f, this));

      if (!ACK_RTT_.present ())
      {
        this->ACK_RTT_.set (r);
        continue;
      }
    }

    // FLAGS
    //
    if (n.name () == "FLAGS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FLAGS_type > r (
        FLAGS_traits::create (i, f, this));

      if (!FLAGS_.present ())
      {
        this->FLAGS_.set (r);
        continue;
      }
    }

    break;
  }

  if (!SEQ_NUMBER_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SEQ_NUMBER",
      "");
  }

  if (!ACK_RTT_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ACK_RTT",
      "");
  }

  if (!FLAGS_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "FLAGS",
      "");
  }
}

TRANSMISSION_PROTOCOLType* TRANSMISSION_PROTOCOLType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TRANSMISSION_PROTOCOLType (*this, f, c);
}

TRANSMISSION_PROTOCOLType& TRANSMISSION_PROTOCOLType::
operator= (const TRANSMISSION_PROTOCOLType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->SEQ_NUMBER_ = x.SEQ_NUMBER_;
    this->ACK_RTT_ = x.ACK_RTT_;
    this->FLAGS_ = x.FLAGS_;
  }

  return *this;
}

TRANSMISSION_PROTOCOLType::
~TRANSMISSION_PROTOCOLType ()
{
}

// DATAType
//

DATAType::
DATAType ()
: ::xml_schema::type (),
  DATA_ID_ (this),
  REF_ (this),
  RANG_ (this),
  TYPE_ (this),
  INFO_ (this),
  Define_ (this),
  VALUE_RAW_ (this),
  VALUE_SYS_ (this)
{
}

DATAType::
DATAType (const DATAType& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  DATA_ID_ (x.DATA_ID_, f, this),
  REF_ (x.REF_, f, this),
  RANG_ (x.RANG_, f, this),
  TYPE_ (x.TYPE_, f, this),
  INFO_ (x.INFO_, f, this),
  Define_ (x.Define_, f, this),
  VALUE_RAW_ (x.VALUE_RAW_, f, this),
  VALUE_SYS_ (x.VALUE_SYS_, f, this)
{
}

DATAType::
DATAType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  DATA_ID_ (this),
  REF_ (this),
  RANG_ (this),
  TYPE_ (this),
  INFO_ (this),
  Define_ (this),
  VALUE_RAW_ (this),
  VALUE_SYS_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DATAType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DATA_ID
    //
    if (n.name () == "DATA_ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DATA_ID_type > r (
        DATA_ID_traits::create (i, f, this));

      this->DATA_ID_.push_back (r);
      continue;
    }

    // REF
    //
    if (n.name () == "REF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< REF_type > r (
        REF_traits::create (i, f, this));

      this->REF_.push_back (r);
      continue;
    }

    // RANG
    //
    if (n.name () == "RANG" && n.namespace_ ().empty ())
    {
      this->RANG_.push_back (RANG_traits::create (i, f, this));
      continue;
    }

    // TYPE
    //
    if (n.name () == "TYPE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TYPE_type > r (
        TYPE_traits::create (i, f, this));

      this->TYPE_.push_back (r);
      continue;
    }

    // INFO
    //
    if (n.name () == "INFO" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< INFO_type > r (
        INFO_traits::create (i, f, this));

      this->INFO_.push_back (r);
      continue;
    }

    // Define
    //
    if (n.name () == "Define" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Define_type > r (
        Define_traits::create (i, f, this));

      this->Define_.push_back (r);
      continue;
    }

    // VALUE_RAW
    //
    if (n.name () == "VALUE_RAW" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< VALUE_RAW_type > r (
        VALUE_RAW_traits::create (i, f, this));

      this->VALUE_RAW_.push_back (r);
      continue;
    }

    // VALUE_SYS
    //
    if (n.name () == "VALUE_SYS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< VALUE_SYS_type > r (
        VALUE_SYS_traits::create (i, f, this));

      this->VALUE_SYS_.push_back (r);
      continue;
    }

    break;
  }
}

DATAType* DATAType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DATAType (*this, f, c);
}

DATAType& DATAType::
operator= (const DATAType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->DATA_ID_ = x.DATA_ID_;
    this->REF_ = x.REF_;
    this->RANG_ = x.RANG_;
    this->TYPE_ = x.TYPE_;
    this->INFO_ = x.INFO_;
    this->Define_ = x.Define_;
    this->VALUE_RAW_ = x.VALUE_RAW_;
    this->VALUE_SYS_ = x.VALUE_SYS_;
  }

  return *this;
}

DATAType::
~DATAType ()
{
}

// DATA_SETType
//

DATA_SETType::
DATA_SETType (const RAW_type& RAW)
: ::xml_schema::type (),
  DATA_FORMAT_ (this),
  REF_PARSE_DATA_ (this),
  RAW_ (RAW, this),
  DATA_ (this)
{
}

DATA_SETType::
DATA_SETType (const DATA_SETType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  DATA_FORMAT_ (x.DATA_FORMAT_, f, this),
  REF_PARSE_DATA_ (x.REF_PARSE_DATA_, f, this),
  RAW_ (x.RAW_, f, this),
  DATA_ (x.DATA_, f, this)
{
}

DATA_SETType::
DATA_SETType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  DATA_FORMAT_ (this),
  REF_PARSE_DATA_ (this),
  RAW_ (this),
  DATA_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DATA_SETType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DATA_FORMAT
    //
    if (n.name () == "DATA_FORMAT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DATA_FORMAT_type > r (
        DATA_FORMAT_traits::create (i, f, this));

      if (!this->DATA_FORMAT_)
      {
        this->DATA_FORMAT_.set (r);
        continue;
      }
    }

    // REF_PARSE_DATA
    //
    if (n.name () == "REF_PARSE_DATA" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< REF_PARSE_DATA_type > r (
        REF_PARSE_DATA_traits::create (i, f, this));

      if (!this->REF_PARSE_DATA_)
      {
        this->REF_PARSE_DATA_.set (r);
        continue;
      }
    }

    // RAW
    //
    if (n.name () == "RAW" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RAW_type > r (
        RAW_traits::create (i, f, this));

      if (!RAW_.present ())
      {
        this->RAW_.set (r);
        continue;
      }
    }

    // DATA
    //
    if (n.name () == "DATA" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DATA_type > r (
        DATA_traits::create (i, f, this));

      this->DATA_.push_back (r);
      continue;
    }

    break;
  }

  if (!RAW_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RAW",
      "");
  }
}

DATA_SETType* DATA_SETType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DATA_SETType (*this, f, c);
}

DATA_SETType& DATA_SETType::
operator= (const DATA_SETType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->DATA_FORMAT_ = x.DATA_FORMAT_;
    this->REF_PARSE_DATA_ = x.REF_PARSE_DATA_;
    this->RAW_ = x.RAW_;
    this->DATA_ = x.DATA_;
  }

  return *this;
}

DATA_SETType::
~DATA_SETType ()
{
}

// FRAMEType
//

FRAMEType::
FRAMEType (const IDENTIFIANT_type& IDENTIFIANT,
           const NOM_type& NOM,
           const SOURCE_type& SOURCE,
           const DESTINATION_type& DESTINATION,
           const TIMESTAMP_type& TIMESTAMP,
           const RAW_type& RAW,
           const TYPE_type& TYPE,
           const FRAME_NUMBER_type& FRAME_NUMBER,
           const FRAME_PROTOCOL_type& FRAME_PROTOCOL,
           const IP_PROTOCOL_type& IP_PROTOCOL,
           const TRANSMISSION_PROTOCOL_type& TRANSMISSION_PROTOCOL,
           const DATA_SET_type& DATA_SET)
: ::xml_schema::type (),
  IDENTIFIANT_ (IDENTIFIANT, this),
  NOM_ (NOM, this),
  SOURCE_ (SOURCE, this),
  DESTINATION_ (DESTINATION, this),
  TIMESTAMP_ (TIMESTAMP, this),
  RAW_ (RAW, this),
  TYPE_ (TYPE, this),
  FRAME_NUMBER_ (FRAME_NUMBER, this),
  FRAME_PROTOCOL_ (FRAME_PROTOCOL, this),
  IP_PROTOCOL_ (IP_PROTOCOL, this),
  TRANSMISSION_PROTOCOL_ (TRANSMISSION_PROTOCOL, this),
  DATA_SET_ (DATA_SET, this)
{
}

FRAMEType::
FRAMEType (const IDENTIFIANT_type& IDENTIFIANT,
           const NOM_type& NOM,
           const SOURCE_type& SOURCE,
           const DESTINATION_type& DESTINATION,
           const TIMESTAMP_type& TIMESTAMP,
           const RAW_type& RAW,
           const TYPE_type& TYPE,
           const FRAME_NUMBER_type& FRAME_NUMBER,
           const FRAME_PROTOCOL_type& FRAME_PROTOCOL,
           ::std::auto_ptr< IP_PROTOCOL_type > IP_PROTOCOL,
           ::std::auto_ptr< TRANSMISSION_PROTOCOL_type > TRANSMISSION_PROTOCOL,
           ::std::auto_ptr< DATA_SET_type > DATA_SET)
: ::xml_schema::type (),
  IDENTIFIANT_ (IDENTIFIANT, this),
  NOM_ (NOM, this),
  SOURCE_ (SOURCE, this),
  DESTINATION_ (DESTINATION, this),
  TIMESTAMP_ (TIMESTAMP, this),
  RAW_ (RAW, this),
  TYPE_ (TYPE, this),
  FRAME_NUMBER_ (FRAME_NUMBER, this),
  FRAME_PROTOCOL_ (FRAME_PROTOCOL, this),
  IP_PROTOCOL_ (IP_PROTOCOL, this),
  TRANSMISSION_PROTOCOL_ (TRANSMISSION_PROTOCOL, this),
  DATA_SET_ (DATA_SET, this)
{
}

FRAMEType::
FRAMEType (const FRAMEType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  IDENTIFIANT_ (x.IDENTIFIANT_, f, this),
  NOM_ (x.NOM_, f, this),
  SOURCE_ (x.SOURCE_, f, this),
  DESTINATION_ (x.DESTINATION_, f, this),
  TIMESTAMP_ (x.TIMESTAMP_, f, this),
  RAW_ (x.RAW_, f, this),
  TYPE_ (x.TYPE_, f, this),
  FRAME_NUMBER_ (x.FRAME_NUMBER_, f, this),
  FRAME_PROTOCOL_ (x.FRAME_PROTOCOL_, f, this),
  IP_PROTOCOL_ (x.IP_PROTOCOL_, f, this),
  TRANSMISSION_PROTOCOL_ (x.TRANSMISSION_PROTOCOL_, f, this),
  DATA_SET_ (x.DATA_SET_, f, this)
{
}

FRAMEType::
FRAMEType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  IDENTIFIANT_ (this),
  NOM_ (this),
  SOURCE_ (this),
  DESTINATION_ (this),
  TIMESTAMP_ (this),
  RAW_ (this),
  TYPE_ (this),
  FRAME_NUMBER_ (this),
  FRAME_PROTOCOL_ (this),
  IP_PROTOCOL_ (this),
  TRANSMISSION_PROTOCOL_ (this),
  DATA_SET_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void FRAMEType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // IDENTIFIANT
    //
    if (n.name () == "IDENTIFIANT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IDENTIFIANT_type > r (
        IDENTIFIANT_traits::create (i, f, this));

      if (!IDENTIFIANT_.present ())
      {
        this->IDENTIFIANT_.set (r);
        continue;
      }
    }

    // NOM
    //
    if (n.name () == "NOM" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NOM_type > r (
        NOM_traits::create (i, f, this));

      if (!NOM_.present ())
      {
        this->NOM_.set (r);
        continue;
      }
    }

    // SOURCE
    //
    if (n.name () == "SOURCE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SOURCE_type > r (
        SOURCE_traits::create (i, f, this));

      if (!SOURCE_.present ())
      {
        this->SOURCE_.set (r);
        continue;
      }
    }

    // DESTINATION
    //
    if (n.name () == "DESTINATION" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DESTINATION_type > r (
        DESTINATION_traits::create (i, f, this));

      if (!DESTINATION_.present ())
      {
        this->DESTINATION_.set (r);
        continue;
      }
    }

    // TIMESTAMP
    //
    if (n.name () == "TIMESTAMP" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TIMESTAMP_type > r (
        TIMESTAMP_traits::create (i, f, this));

      if (!TIMESTAMP_.present ())
      {
        this->TIMESTAMP_.set (r);
        continue;
      }
    }

    // RAW
    //
    if (n.name () == "RAW" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RAW_type > r (
        RAW_traits::create (i, f, this));

      if (!RAW_.present ())
      {
        this->RAW_.set (r);
        continue;
      }
    }

    // TYPE
    //
    if (n.name () == "TYPE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TYPE_type > r (
        TYPE_traits::create (i, f, this));

      if (!TYPE_.present ())
      {
        this->TYPE_.set (r);
        continue;
      }
    }

    // FRAME_NUMBER
    //
    if (n.name () == "FRAME_NUMBER" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FRAME_NUMBER_type > r (
        FRAME_NUMBER_traits::create (i, f, this));

      if (!FRAME_NUMBER_.present ())
      {
        this->FRAME_NUMBER_.set (r);
        continue;
      }
    }

    // FRAME_PROTOCOL
    //
    if (n.name () == "FRAME_PROTOCOL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FRAME_PROTOCOL_type > r (
        FRAME_PROTOCOL_traits::create (i, f, this));

      if (!FRAME_PROTOCOL_.present ())
      {
        this->FRAME_PROTOCOL_.set (r);
        continue;
      }
    }

    // IP_PROTOCOL
    //
    if (n.name () == "IP_PROTOCOL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IP_PROTOCOL_type > r (
        IP_PROTOCOL_traits::create (i, f, this));

      if (!IP_PROTOCOL_.present ())
      {
        this->IP_PROTOCOL_.set (r);
        continue;
      }
    }

    // TRANSMISSION_PROTOCOL
    //
    if (n.name () == "TRANSMISSION_PROTOCOL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TRANSMISSION_PROTOCOL_type > r (
        TRANSMISSION_PROTOCOL_traits::create (i, f, this));

      if (!TRANSMISSION_PROTOCOL_.present ())
      {
        this->TRANSMISSION_PROTOCOL_.set (r);
        continue;
      }
    }

    // DATA_SET
    //
    if (n.name () == "DATA_SET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DATA_SET_type > r (
        DATA_SET_traits::create (i, f, this));

      if (!DATA_SET_.present ())
      {
        this->DATA_SET_.set (r);
        continue;
      }
    }

    break;
  }

  if (!IDENTIFIANT_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "IDENTIFIANT",
      "");
  }

  if (!NOM_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "NOM",
      "");
  }

  if (!SOURCE_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SOURCE",
      "");
  }

  if (!DESTINATION_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DESTINATION",
      "");
  }

  if (!TIMESTAMP_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TIMESTAMP",
      "");
  }

  if (!RAW_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RAW",
      "");
  }

  if (!TYPE_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TYPE",
      "");
  }

  if (!FRAME_NUMBER_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "FRAME_NUMBER",
      "");
  }

  if (!FRAME_PROTOCOL_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "FRAME_PROTOCOL",
      "");
  }

  if (!IP_PROTOCOL_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "IP_PROTOCOL",
      "");
  }

  if (!TRANSMISSION_PROTOCOL_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TRANSMISSION_PROTOCOL",
      "");
  }

  if (!DATA_SET_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DATA_SET",
      "");
  }
}

FRAMEType* FRAMEType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FRAMEType (*this, f, c);
}

FRAMEType& FRAMEType::
operator= (const FRAMEType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->IDENTIFIANT_ = x.IDENTIFIANT_;
    this->NOM_ = x.NOM_;
    this->SOURCE_ = x.SOURCE_;
    this->DESTINATION_ = x.DESTINATION_;
    this->TIMESTAMP_ = x.TIMESTAMP_;
    this->RAW_ = x.RAW_;
    this->TYPE_ = x.TYPE_;
    this->FRAME_NUMBER_ = x.FRAME_NUMBER_;
    this->FRAME_PROTOCOL_ = x.FRAME_PROTOCOL_;
    this->IP_PROTOCOL_ = x.IP_PROTOCOL_;
    this->TRANSMISSION_PROTOCOL_ = x.TRANSMISSION_PROTOCOL_;
    this->DATA_SET_ = x.DATA_SET_;
  }

  return *this;
}

FRAMEType::
~FRAMEType ()
{
}

// OUTPUTType
//

OUTPUTType::
OUTPUTType (const TEST_REF_type& TEST_REF,
            const TOOL_CFG_type& TOOL_CFG)
: ::xml_schema::type (),
  TEST_REF_ (TEST_REF, this),
  TOOL_CFG_ (TOOL_CFG, this),
  FRAME_ (this)
{
}

OUTPUTType::
OUTPUTType (::std::auto_ptr< TEST_REF_type > TEST_REF,
            ::std::auto_ptr< TOOL_CFG_type > TOOL_CFG)
: ::xml_schema::type (),
  TEST_REF_ (TEST_REF, this),
  TOOL_CFG_ (TOOL_CFG, this),
  FRAME_ (this)
{
}

OUTPUTType::
OUTPUTType (const OUTPUTType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  TEST_REF_ (x.TEST_REF_, f, this),
  TOOL_CFG_ (x.TOOL_CFG_, f, this),
  FRAME_ (x.FRAME_, f, this)
{
}

OUTPUTType::
OUTPUTType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  TEST_REF_ (this),
  TOOL_CFG_ (this),
  FRAME_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void OUTPUTType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TEST_REF
    //
    if (n.name () == "TEST_REF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TEST_REF_type > r (
        TEST_REF_traits::create (i, f, this));

      if (!TEST_REF_.present ())
      {
        this->TEST_REF_.set (r);
        continue;
      }
    }

    // TOOL_CFG
    //
    if (n.name () == "TOOL_CFG" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TOOL_CFG_type > r (
        TOOL_CFG_traits::create (i, f, this));

      if (!TOOL_CFG_.present ())
      {
        this->TOOL_CFG_.set (r);
        continue;
      }
    }

    // FRAME
    //
    if (n.name () == "FRAME" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FRAME_type > r (
        FRAME_traits::create (i, f, this));

      this->FRAME_.push_back (r);
      continue;
    }

    break;
  }

  if (!TEST_REF_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TEST_REF",
      "");
  }

  if (!TOOL_CFG_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TOOL_CFG",
      "");
  }
}

OUTPUTType* OUTPUTType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OUTPUTType (*this, f, c);
}

OUTPUTType& OUTPUTType::
operator= (const OUTPUTType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->TEST_REF_ = x.TEST_REF_;
    this->TOOL_CFG_ = x.TOOL_CFG_;
    this->FRAME_ = x.FRAME_;
  }

  return *this;
}

OUTPUTType::
~OUTPUTType ()
{
}

// BDD_OUTPUT_DATAType
//

BDD_OUTPUT_DATAType::
BDD_OUTPUT_DATAType (const OUTPUT_type& OUTPUT)
: ::xml_schema::type (),
  OUTPUT_ (OUTPUT, this)
{
}

BDD_OUTPUT_DATAType::
BDD_OUTPUT_DATAType (::std::auto_ptr< OUTPUT_type > OUTPUT)
: ::xml_schema::type (),
  OUTPUT_ (OUTPUT, this)
{
}

BDD_OUTPUT_DATAType::
BDD_OUTPUT_DATAType (const BDD_OUTPUT_DATAType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  OUTPUT_ (x.OUTPUT_, f, this)
{
}

BDD_OUTPUT_DATAType::
BDD_OUTPUT_DATAType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  OUTPUT_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void BDD_OUTPUT_DATAType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // OUTPUT
    //
    if (n.name () == "OUTPUT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< OUTPUT_type > r (
        OUTPUT_traits::create (i, f, this));

      if (!OUTPUT_.present ())
      {
        this->OUTPUT_.set (r);
        continue;
      }
    }

    break;
  }

  if (!OUTPUT_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "OUTPUT",
      "");
  }
}

BDD_OUTPUT_DATAType* BDD_OUTPUT_DATAType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BDD_OUTPUT_DATAType (*this, f, c);
}

BDD_OUTPUT_DATAType& BDD_OUTPUT_DATAType::
operator= (const BDD_OUTPUT_DATAType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->OUTPUT_ = x.OUTPUT_;
  }

  return *this;
}

BDD_OUTPUT_DATAType::
~BDD_OUTPUT_DATAType ()
{
}

// DATATypeTYPE
//

DATATypeTYPE::
DATATypeTYPE (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_DATATypeTYPE_convert ();
}

DATATypeTYPE::
DATATypeTYPE (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_DATATypeTYPE_convert ();
}

DATATypeTYPE::
DATATypeTYPE (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_DATATypeTYPE_convert ();
}

DATATypeTYPE* DATATypeTYPE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DATATypeTYPE (*this, f, c);
}

DATATypeTYPE::value DATATypeTYPE::
_xsd_DATATypeTYPE_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DATATypeTYPE_literals_);
  const value* i (::std::lower_bound (
                    _xsd_DATATypeTYPE_indexes_,
                    _xsd_DATATypeTYPE_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_DATATypeTYPE_indexes_ + 3 || _xsd_DATATypeTYPE_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const DATATypeTYPE::
_xsd_DATATypeTYPE_literals_[3] =
{
  "UINT16",
  "BIT",
  "HM"
};

const DATATypeTYPE::value DATATypeTYPE::
_xsd_DATATypeTYPE_indexes_[3] =
{
  ::DATATypeTYPE::BIT,
  ::DATATypeTYPE::HM,
  ::DATATypeTYPE::UINT16
};

// FRAMETypeIDENTIFIANT
//

FRAMETypeIDENTIFIANT::
FRAMETypeIDENTIFIANT (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_FRAMETypeIDENTIFIANT_convert ();
}

FRAMETypeIDENTIFIANT::
FRAMETypeIDENTIFIANT (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_FRAMETypeIDENTIFIANT_convert ();
}

FRAMETypeIDENTIFIANT::
FRAMETypeIDENTIFIANT (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_FRAMETypeIDENTIFIANT_convert ();
}

FRAMETypeIDENTIFIANT* FRAMETypeIDENTIFIANT::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FRAMETypeIDENTIFIANT (*this, f, c);
}

FRAMETypeIDENTIFIANT::value FRAMETypeIDENTIFIANT::
_xsd_FRAMETypeIDENTIFIANT_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_FRAMETypeIDENTIFIANT_literals_);
  const value* i (::std::lower_bound (
                    _xsd_FRAMETypeIDENTIFIANT_indexes_,
                    _xsd_FRAMETypeIDENTIFIANT_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_FRAMETypeIDENTIFIANT_indexes_ + 2 || _xsd_FRAMETypeIDENTIFIANT_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const FRAMETypeIDENTIFIANT::
_xsd_FRAMETypeIDENTIFIANT_literals_[2] =
{
  "SNBISUGO1_SNBISMOD1_Mod_P",
  "SNBISMOD1_Mod_P_SNBISUGO1"
};

const FRAMETypeIDENTIFIANT::value FRAMETypeIDENTIFIANT::
_xsd_FRAMETypeIDENTIFIANT_indexes_[2] =
{
  ::FRAMETypeIDENTIFIANT::SNBISMOD1_Mod_P_SNBISUGO1,
  ::FRAMETypeIDENTIFIANT::SNBISUGO1_SNBISMOD1_Mod_P
};

// FRAMETypeNOM
//

FRAMETypeNOM::
FRAMETypeNOM (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_FRAMETypeNOM_convert ();
}

FRAMETypeNOM::
FRAMETypeNOM (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_FRAMETypeNOM_convert ();
}

FRAMETypeNOM::
FRAMETypeNOM (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_FRAMETypeNOM_convert ();
}

FRAMETypeNOM* FRAMETypeNOM::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FRAMETypeNOM (*this, f, c);
}

FRAMETypeNOM::value FRAMETypeNOM::
_xsd_FRAMETypeNOM_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_FRAMETypeNOM_literals_);
  const value* i (::std::lower_bound (
                    _xsd_FRAMETypeNOM_indexes_,
                    _xsd_FRAMETypeNOM_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_FRAMETypeNOM_indexes_ + 2 || _xsd_FRAMETypeNOM_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const FRAMETypeNOM::
_xsd_FRAMETypeNOM_literals_[2] =
{
  "UGO 1 BIS vers MOD 1 BIS",
  "MOD 1 BIS vers UGO 1 BIS"
};

const FRAMETypeNOM::value FRAMETypeNOM::
_xsd_FRAMETypeNOM_indexes_[2] =
{
  ::FRAMETypeNOM::MOD_1_BIS_vers_UGO_1_BIS,
  ::FRAMETypeNOM::UGO_1_BIS_vers_MOD_1_BIS
};

// FRAMETypeSOURCE
//

FRAMETypeSOURCE::
FRAMETypeSOURCE (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_FRAMETypeSOURCE_convert ();
}

FRAMETypeSOURCE::
FRAMETypeSOURCE (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_FRAMETypeSOURCE_convert ();
}

FRAMETypeSOURCE::
FRAMETypeSOURCE (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_FRAMETypeSOURCE_convert ();
}

FRAMETypeSOURCE* FRAMETypeSOURCE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FRAMETypeSOURCE (*this, f, c);
}

FRAMETypeSOURCE::value FRAMETypeSOURCE::
_xsd_FRAMETypeSOURCE_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_FRAMETypeSOURCE_literals_);
  const value* i (::std::lower_bound (
                    _xsd_FRAMETypeSOURCE_indexes_,
                    _xsd_FRAMETypeSOURCE_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_FRAMETypeSOURCE_indexes_ + 2 || _xsd_FRAMETypeSOURCE_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const FRAMETypeSOURCE::
_xsd_FRAMETypeSOURCE_literals_[2] =
{
  "SNBISUGO1_CPU_P",
  "SNBISMOD1_Mod"
};

const FRAMETypeSOURCE::value FRAMETypeSOURCE::
_xsd_FRAMETypeSOURCE_indexes_[2] =
{
  ::FRAMETypeSOURCE::SNBISMOD1_Mod,
  ::FRAMETypeSOURCE::SNBISUGO1_CPU_P
};

// FRAMETypeDESTINATION
//

FRAMETypeDESTINATION::
FRAMETypeDESTINATION (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_FRAMETypeDESTINATION_convert ();
}

FRAMETypeDESTINATION::
FRAMETypeDESTINATION (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_FRAMETypeDESTINATION_convert ();
}

FRAMETypeDESTINATION::
FRAMETypeDESTINATION (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_FRAMETypeDESTINATION_convert ();
}

FRAMETypeDESTINATION* FRAMETypeDESTINATION::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FRAMETypeDESTINATION (*this, f, c);
}

FRAMETypeDESTINATION::value FRAMETypeDESTINATION::
_xsd_FRAMETypeDESTINATION_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_FRAMETypeDESTINATION_literals_);
  const value* i (::std::lower_bound (
                    _xsd_FRAMETypeDESTINATION_indexes_,
                    _xsd_FRAMETypeDESTINATION_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_FRAMETypeDESTINATION_indexes_ + 2 || _xsd_FRAMETypeDESTINATION_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const FRAMETypeDESTINATION::
_xsd_FRAMETypeDESTINATION_literals_[2] =
{
  "SNBISMOD1_Mod",
  "SNBISUGO1_CPU_P"
};

const FRAMETypeDESTINATION::value FRAMETypeDESTINATION::
_xsd_FRAMETypeDESTINATION_indexes_[2] =
{
  ::FRAMETypeDESTINATION::SNBISMOD1_Mod,
  ::FRAMETypeDESTINATION::SNBISUGO1_CPU_P
};

// FRAMETypeTYPE
//

FRAMETypeTYPE::
FRAMETypeTYPE (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_FRAMETypeTYPE_convert ();
}

FRAMETypeTYPE::
FRAMETypeTYPE (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_FRAMETypeTYPE_convert ();
}

FRAMETypeTYPE::
FRAMETypeTYPE (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_FRAMETypeTYPE_convert ();
}

FRAMETypeTYPE* FRAMETypeTYPE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FRAMETypeTYPE (*this, f, c);
}

FRAMETypeTYPE::value FRAMETypeTYPE::
_xsd_FRAMETypeTYPE_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_FRAMETypeTYPE_literals_);
  const value* i (::std::lower_bound (
                    _xsd_FRAMETypeTYPE_indexes_,
                    _xsd_FRAMETypeTYPE_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_FRAMETypeTYPE_indexes_ + 2 || _xsd_FRAMETypeTYPE_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const FRAMETypeTYPE::
_xsd_FRAMETypeTYPE_literals_[2] =
{
  "QUERY",
  "RESPONSE"
};

const FRAMETypeTYPE::value FRAMETypeTYPE::
_xsd_FRAMETypeTYPE_indexes_[2] =
{
  ::FRAMETypeTYPE::QUERY,
  ::FRAMETypeTYPE::RESPONSE
};

// FRAMETypeFRAME_NUMBER
//

FRAMETypeFRAME_NUMBER::
FRAMETypeFRAME_NUMBER (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_FRAMETypeFRAME_NUMBER_convert ();
}

FRAMETypeFRAME_NUMBER::
FRAMETypeFRAME_NUMBER (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_FRAMETypeFRAME_NUMBER_convert ();
}

FRAMETypeFRAME_NUMBER::
FRAMETypeFRAME_NUMBER (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_FRAMETypeFRAME_NUMBER_convert ();
}

FRAMETypeFRAME_NUMBER* FRAMETypeFRAME_NUMBER::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FRAMETypeFRAME_NUMBER (*this, f, c);
}

FRAMETypeFRAME_NUMBER::value FRAMETypeFRAME_NUMBER::
_xsd_FRAMETypeFRAME_NUMBER_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_FRAMETypeFRAME_NUMBER_literals_);
  const value* i (::std::lower_bound (
                    _xsd_FRAMETypeFRAME_NUMBER_indexes_,
                    _xsd_FRAMETypeFRAME_NUMBER_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_FRAMETypeFRAME_NUMBER_indexes_ + 2 || _xsd_FRAMETypeFRAME_NUMBER_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const FRAMETypeFRAME_NUMBER::
_xsd_FRAMETypeFRAME_NUMBER_literals_[2] =
{
  "76",
  "234"
};

const FRAMETypeFRAME_NUMBER::value FRAMETypeFRAME_NUMBER::
_xsd_FRAMETypeFRAME_NUMBER_indexes_[2] =
{
  ::FRAMETypeFRAME_NUMBER::cxx_234,
  ::FRAMETypeFRAME_NUMBER::cxx_76
};

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::BDD_OUTPUT_DATAType > (
    ::BDD_OUTPUT_DATA (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::BDD_OUTPUT_DATAType > (
    ::BDD_OUTPUT_DATA (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::BDD_OUTPUT_DATAType > (
    ::BDD_OUTPUT_DATA (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::BDD_OUTPUT_DATA (isrc, f, p);
}

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::BDD_OUTPUT_DATA (isrc, h, f, p);
}

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::BDD_OUTPUT_DATA (isrc, h, f, p);
}

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::BDD_OUTPUT_DATA (isrc, f, p);
}

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::BDD_OUTPUT_DATA (isrc, h, f, p);
}

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::BDD_OUTPUT_DATA (isrc, h, f, p);
}

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::BDD_OUTPUT_DATAType > (
    ::BDD_OUTPUT_DATA (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::BDD_OUTPUT_DATAType > (
    ::BDD_OUTPUT_DATA (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::BDD_OUTPUT_DATAType > (
    ::BDD_OUTPUT_DATA (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::BDD_OUTPUT_DATAType > (
      ::BDD_OUTPUT_DATA (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "BDD_OUTPUT_DATA" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::BDD_OUTPUT_DATAType > r (
      ::xsd::cxx::tree::traits< ::BDD_OUTPUT_DATAType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "BDD_OUTPUT_DATA",
    "");
}

::std::auto_ptr< ::BDD_OUTPUT_DATAType >
BDD_OUTPUT_DATA (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "BDD_OUTPUT_DATA" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::BDD_OUTPUT_DATAType > r (
      ::xsd::cxx::tree::traits< ::BDD_OUTPUT_DATAType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "BDD_OUTPUT_DATA",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
BDD_OUTPUT_DATA (::std::ostream& o,
                 const ::BDD_OUTPUT_DATAType& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::BDD_OUTPUT_DATA (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
BDD_OUTPUT_DATA (::std::ostream& o,
                 const ::BDD_OUTPUT_DATAType& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::BDD_OUTPUT_DATA (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
BDD_OUTPUT_DATA (::std::ostream& o,
                 const ::BDD_OUTPUT_DATAType& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::BDD_OUTPUT_DATA (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
BDD_OUTPUT_DATA (::xercesc::XMLFormatTarget& t,
                 const ::BDD_OUTPUT_DATAType& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::BDD_OUTPUT_DATA (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
BDD_OUTPUT_DATA (::xercesc::XMLFormatTarget& t,
                 const ::BDD_OUTPUT_DATAType& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::BDD_OUTPUT_DATA (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
BDD_OUTPUT_DATA (::xercesc::XMLFormatTarget& t,
                 const ::BDD_OUTPUT_DATAType& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::BDD_OUTPUT_DATA (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
BDD_OUTPUT_DATA (::xercesc::DOMDocument& d,
                 const ::BDD_OUTPUT_DATAType& s,
                 ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "BDD_OUTPUT_DATA" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "BDD_OUTPUT_DATA",
      "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
BDD_OUTPUT_DATA (const ::BDD_OUTPUT_DATAType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "BDD_OUTPUT_DATA",
      "",
      m, f));

  ::BDD_OUTPUT_DATA (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const EXIGENCESType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // ID_EXI
  //
  for (EXIGENCESType::ID_EXI_const_iterator
       b (i.ID_EXI ().begin ()), n (i.ID_EXI ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ID_EXI",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const LOGICIELType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // SSG
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SSG",
        e));

    s << i.SSG ();
  }

  // SST
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SST",
        e));

    s << i.SST ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const MATERIELType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // SSG
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SSG",
        e));

    s << i.SSG ();
  }

  // SST
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SST",
        e));

    s << i.SST ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const CONFIGURATIONType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // LOGICIEL
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "LOGICIEL",
        e));

    s << i.LOGICIEL ();
  }

  // MATERIEL
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MATERIEL",
        e));

    s << i.MATERIEL ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const TEST_REFType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // TEST_ID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TEST_ID",
        e));

    s << i.TEST_ID ();
  }

  // ORIGINE
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ORIGINE",
        e));

    s << i.ORIGINE ();
  }

  // TITRE
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TITRE",
        e));

    s << i.TITRE ();
  }

  // REFERENCE_PROCEDURE
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "REFERENCE_PROCEDURE",
        e));

    s << i.REFERENCE_PROCEDURE ();
  }

  // VERSION_PROCEDURE
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "VERSION_PROCEDURE",
        e));

    s << i.VERSION_PROCEDURE ();
  }

  // SECTION_PROCEDURE
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SECTION_PROCEDURE",
        e));

    s << i.SECTION_PROCEDURE ();
  }

  // EXIGENCES
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EXIGENCES",
        e));

    s << i.EXIGENCES ();
  }

  // CONFIGURATION
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CONFIGURATION",
        e));

    s << i.CONFIGURATION ();
  }

  // DATE
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DATE",
        e));

    s << i.DATE ();
  }

  // HEURE
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "HEURE",
        e));

    s << i.HEURE ();
  }

  // LIEU
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "LIEU",
        e));

    s << i.LIEU ();
  }

  // OPERATEUR
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "OPERATEUR",
        e));

    s << i.OPERATEUR ();
  }

  // COMMENT
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "COMMENT",
        e));

    s << i.COMMENT ();
  }

  // VALIDITE
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "VALIDITE",
        e));

    s << i.VALIDITE ();
  }

  // SAUVEGARDE
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SAUVEGARDE",
        e));

    s << i.SAUVEGARDE ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const FILESType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // CFG_IP
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CFG_IP",
        e));

    s << i.CFG_IP ();
  }

  // CFG_FLUX
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CFG_FLUX",
        e));

    s << i.CFG_FLUX ();
  }

  // CFG_DATA
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CFG_DATA",
        e));

    s << i.CFG_DATA ();
  }

  // CFG_DATA_VAL
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CFG_DATA_VAL",
        e));

    s << i.CFG_DATA_VAL ();
  }

  // CFG_TEST
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CFG_TEST",
        e));

    s << i.CFG_TEST ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const TOOL_CFGType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // IDENT
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IDENT",
        e));

    s << i.IDENT ();
  }

  // VERSION
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "VERSION",
        e));

    s << i.VERSION ();
  }

  // FILES
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FILES",
        e));

    s << i.FILES ();
  }

  // DATE
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DATE",
        e));

    s << i.DATE ();
  }

  // HEURE
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "HEURE",
        e));

    s << i.HEURE ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const IP_PROTOCOLType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // FLAGS
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FLAGS",
        e));

    s << i.FLAGS ();
  }

  // Header_CHECKSUM
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Header_CHECKSUM",
        e));

    s << i.Header_CHECKSUM ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const TRANSMISSION_PROTOCOLType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // SEQ_NUMBER
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SEQ_NUMBER",
        e));

    s << i.SEQ_NUMBER ();
  }

  // ACK_RTT
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ACK_RTT",
        e));

    s << i.ACK_RTT ();
  }

  // FLAGS
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FLAGS",
        e));

    s << i.FLAGS ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DATAType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // DATA_ID
  //
  for (DATAType::DATA_ID_const_iterator
       b (i.DATA_ID ().begin ()), n (i.DATA_ID ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DATA_ID",
        e));

    s << *b;
  }

  // REF
  //
  for (DATAType::REF_const_iterator
       b (i.REF ().begin ()), n (i.REF ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "REF",
        e));

    s << *b;
  }

  // RANG
  //
  for (DATAType::RANG_const_iterator
       b (i.RANG ().begin ()), n (i.RANG ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RANG",
        e));

    s << *b;
  }

  // TYPE
  //
  for (DATAType::TYPE_const_iterator
       b (i.TYPE ().begin ()), n (i.TYPE ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TYPE",
        e));

    s << *b;
  }

  // INFO
  //
  for (DATAType::INFO_const_iterator
       b (i.INFO ().begin ()), n (i.INFO ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "INFO",
        e));

    s << *b;
  }

  // Define
  //
  for (DATAType::Define_const_iterator
       b (i.Define ().begin ()), n (i.Define ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Define",
        e));

    s << *b;
  }

  // VALUE_RAW
  //
  for (DATAType::VALUE_RAW_const_iterator
       b (i.VALUE_RAW ().begin ()), n (i.VALUE_RAW ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "VALUE_RAW",
        e));

    s << *b;
  }

  // VALUE_SYS
  //
  for (DATAType::VALUE_SYS_const_iterator
       b (i.VALUE_SYS ().begin ()), n (i.VALUE_SYS ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "VALUE_SYS",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const DATA_SETType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // DATA_FORMAT
  //
  if (i.DATA_FORMAT ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DATA_FORMAT",
        e));

    s << *i.DATA_FORMAT ();
  }

  // REF_PARSE_DATA
  //
  if (i.REF_PARSE_DATA ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "REF_PARSE_DATA",
        e));

    s << *i.REF_PARSE_DATA ();
  }

  // RAW
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RAW",
        e));

    s << i.RAW ();
  }

  // DATA
  //
  for (DATA_SETType::DATA_const_iterator
       b (i.DATA ().begin ()), n (i.DATA ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DATA",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const FRAMEType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // IDENTIFIANT
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IDENTIFIANT",
        e));

    s << i.IDENTIFIANT ();
  }

  // NOM
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "NOM",
        e));

    s << i.NOM ();
  }

  // SOURCE
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SOURCE",
        e));

    s << i.SOURCE ();
  }

  // DESTINATION
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DESTINATION",
        e));

    s << i.DESTINATION ();
  }

  // TIMESTAMP
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TIMESTAMP",
        e));

    s << i.TIMESTAMP ();
  }

  // RAW
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RAW",
        e));

    s << i.RAW ();
  }

  // TYPE
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TYPE",
        e));

    s << i.TYPE ();
  }

  // FRAME_NUMBER
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FRAME_NUMBER",
        e));

    s << i.FRAME_NUMBER ();
  }

  // FRAME_PROTOCOL
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FRAME_PROTOCOL",
        e));

    s << i.FRAME_PROTOCOL ();
  }

  // IP_PROTOCOL
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IP_PROTOCOL",
        e));

    s << i.IP_PROTOCOL ();
  }

  // TRANSMISSION_PROTOCOL
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TRANSMISSION_PROTOCOL",
        e));

    s << i.TRANSMISSION_PROTOCOL ();
  }

  // DATA_SET
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DATA_SET",
        e));

    s << i.DATA_SET ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const OUTPUTType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // TEST_REF
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TEST_REF",
        e));

    s << i.TEST_REF ();
  }

  // TOOL_CFG
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TOOL_CFG",
        e));

    s << i.TOOL_CFG ();
  }

  // FRAME
  //
  for (OUTPUTType::FRAME_const_iterator
       b (i.FRAME ().begin ()), n (i.FRAME ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FRAME",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const BDD_OUTPUT_DATAType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // OUTPUT
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "OUTPUT",
        e));

    s << i.OUTPUT ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DATATypeTYPE& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const DATATypeTYPE& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const DATATypeTYPE& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const FRAMETypeIDENTIFIANT& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const FRAMETypeIDENTIFIANT& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const FRAMETypeIDENTIFIANT& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const FRAMETypeNOM& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const FRAMETypeNOM& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const FRAMETypeNOM& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const FRAMETypeSOURCE& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const FRAMETypeSOURCE& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const FRAMETypeSOURCE& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const FRAMETypeDESTINATION& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const FRAMETypeDESTINATION& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const FRAMETypeDESTINATION& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const FRAMETypeTYPE& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const FRAMETypeTYPE& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const FRAMETypeTYPE& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const FRAMETypeFRAME_NUMBER& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const FRAMETypeFRAME_NUMBER& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const FRAMETypeFRAME_NUMBER& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

